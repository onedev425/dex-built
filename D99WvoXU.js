var La=Object.defineProperty;var Ca=(r,t,e)=>t in r?La(r,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):r[t]=e;var It=(r,t,e)=>(Ca(r,typeof t!="symbol"?t+"":t,e),e);import{gH as ro,dM as no,gI as io,cE as he,gB as Ta,gy as yt,gJ as Oa,gK as oo,gL as Y,gM as so,gF as Pa,gN as Ra,gO as Ua,$ as ao,z as co,gG as uo,s as Na}from"./assets/index-CyIKZwcA.js";(function(){try{var r=typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{},t=new Error().stack;t&&(r._sentryDebugIds=r._sentryDebugIds||{},r._sentryDebugIds[t]="74a52305-a2a4-42b6-9d65-d13edfa01c26",r._sentryDebugIdIdentifier="sentry-dbid-74a52305-a2a4-42b6-9d65-d13edfa01c26")}catch{}})();function lo(r){if(!Number.isSafeInteger(r)||r<0)throw new Error(`positive integer expected, not ${r}`)}function za(r){return r instanceof Uint8Array||r!=null&&typeof r=="object"&&r.constructor.name==="Uint8Array"}function Mr(r,...t){if(!za(r))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(r.length))throw new Error(`Uint8Array expected of length ${t}, not of length=${r.length}`)}function Ha(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");lo(r.outputLen),lo(r.blockLen)}function jr(r,t=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(t&&r.finished)throw new Error("Hash#digest() has already been called")}function qa(r,t){Mr(r);const e=t.outputLen;if(r.length<e)throw new Error(`digestInto() expects output buffer of length at least ${e}`)}const Nn=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const zn=r=>new DataView(r.buffer,r.byteOffset,r.byteLength),de=(r,t)=>r<<32-t|r>>>t;new Uint8Array(new Uint32Array([287454020]).buffer)[0];function Fa(r){if(typeof r!="string")throw new Error(`utf8ToBytes expected string, got ${typeof r}`);return new Uint8Array(new TextEncoder().encode(r))}function Hn(r){return typeof r=="string"&&(r=Fa(r)),Mr(r),r}function Ka(...r){let t=0;for(let n=0;n<r.length;n++){const i=r[n];Mr(i),t+=i.length}const e=new Uint8Array(t);for(let n=0,i=0;n<r.length;n++){const o=r[n];e.set(o,i),i+=o.length}return e}class ho{clone(){return this._cloneInto()}}function fo(r){const t=n=>r().update(Hn(n)).digest(),e=r();return t.outputLen=e.outputLen,t.blockLen=e.blockLen,t.create=()=>r(),t}function po(r=32){if(Nn&&typeof Nn.getRandomValues=="function")return Nn.getRandomValues(new Uint8Array(r));throw new Error("crypto.getRandomValues must be defined")}function Wa(r,t,e,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(t,e,n);const i=BigInt(32),o=BigInt(4294967295),s=Number(e>>i&o),a=Number(e&o),c=n?4:0,u=n?0:4;r.setUint32(t+c,s,n),r.setUint32(t+u,a,n)}const $a=(r,t,e)=>r&t^~r&e,Ma=(r,t,e)=>r&t^r&e^t&e;class go extends ho{constructor(t,e,n,i){super(),this.blockLen=t,this.outputLen=e,this.padOffset=n,this.isLE=i,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=zn(this.buffer)}update(t){jr(this);const{view:e,buffer:n,blockLen:i}=this;t=Hn(t);const o=t.length;for(let s=0;s<o;){const a=Math.min(i-this.pos,o-s);if(a===i){const c=zn(t);for(;i<=o-s;s+=i)this.process(c,s);continue}n.set(t.subarray(s,s+a),this.pos),this.pos+=a,s+=a,this.pos===i&&(this.process(e,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){jr(this),qa(t,this),this.finished=!0;const{buffer:e,view:n,blockLen:i,isLE:o}=this;let{pos:s}=this;e[s++]=128,this.buffer.subarray(s).fill(0),this.padOffset>i-s&&(this.process(n,0),s=0);for(let h=s;h<i;h++)e[h]=0;Wa(n,i-8,BigInt(this.length*8),o),this.process(n,0);const a=zn(t),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const u=c/4,l=this.get();if(u>l.length)throw new Error("_sha2: outputLen bigger than state");for(let h=0;h<u;h++)a.setUint32(4*h,l[h],o)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const n=t.slice(0,e);return this.destroy(),n}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:n,length:i,finished:o,destroyed:s,pos:a}=this;return t.length=i,t.pos=a,t.finished=o,t.destroyed=s,i%e&&t.buffer.set(n),t}}const Dr=BigInt(2**32-1),qn=BigInt(32);function yo(r,t=!1){return t?{h:Number(r&Dr),l:Number(r>>qn&Dr)}:{h:Number(r>>qn&Dr)|0,l:Number(r&Dr)|0}}function ja(r,t=!1){let e=new Uint32Array(r.length),n=new Uint32Array(r.length);for(let i=0;i<r.length;i++){const{h:o,l:s}=yo(r[i],t);[e[i],n[i]]=[o,s]}return[e,n]}const Da=(r,t)=>BigInt(r>>>0)<<qn|BigInt(t>>>0),Va=(r,t,e)=>r>>>e,Ga=(r,t,e)=>r<<32-e|t>>>e,Za=(r,t,e)=>r>>>e|t<<32-e,Ja=(r,t,e)=>r<<32-e|t>>>e,Ya=(r,t,e)=>r<<64-e|t>>>e-32,Xa=(r,t,e)=>r>>>e-32|t<<64-e,Qa=(r,t)=>t,tc=(r,t)=>r,ec=(r,t,e)=>r<<e|t>>>32-e,rc=(r,t,e)=>t<<e|r>>>32-e,nc=(r,t,e)=>t<<e-32|r>>>64-e,ic=(r,t,e)=>r<<e-32|t>>>64-e;function oc(r,t,e,n){const i=(t>>>0)+(n>>>0);return{h:r+e+(i/2**32|0)|0,l:i|0}}const sc=(r,t,e)=>(r>>>0)+(t>>>0)+(e>>>0),ac=(r,t,e,n)=>t+e+n+(r/2**32|0)|0,cc=(r,t,e,n)=>(r>>>0)+(t>>>0)+(e>>>0)+(n>>>0),uc=(r,t,e,n,i)=>t+e+n+i+(r/2**32|0)|0,lc=(r,t,e,n,i)=>(r>>>0)+(t>>>0)+(e>>>0)+(n>>>0)+(i>>>0),hc=(r,t,e,n,i,o)=>t+e+n+i+o+(r/2**32|0)|0,Q={fromBig:yo,split:ja,toBig:Da,shrSH:Va,shrSL:Ga,rotrSH:Za,rotrSL:Ja,rotrBH:Ya,rotrBL:Xa,rotr32H:Qa,rotr32L:tc,rotlSH:ec,rotlSL:rc,rotlBH:nc,rotlBL:ic,add:oc,add3L:sc,add3H:ac,add4L:cc,add4H:uc,add5H:hc,add5L:lc},[dc,fc]=Q.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(r=>BigInt(r))),_e=new Uint32Array(80),Le=new Uint32Array(80);class pc extends go{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:t,Al:e,Bh:n,Bl:i,Ch:o,Cl:s,Dh:a,Dl:c,Eh:u,El:l,Fh:h,Fl:y,Gh:f,Gl:p,Hh:d,Hl:g}=this;return[t,e,n,i,o,s,a,c,u,l,h,y,f,p,d,g]}set(t,e,n,i,o,s,a,c,u,l,h,y,f,p,d,g){this.Ah=t|0,this.Al=e|0,this.Bh=n|0,this.Bl=i|0,this.Ch=o|0,this.Cl=s|0,this.Dh=a|0,this.Dl=c|0,this.Eh=u|0,this.El=l|0,this.Fh=h|0,this.Fl=y|0,this.Gh=f|0,this.Gl=p|0,this.Hh=d|0,this.Hl=g|0}process(t,e){for(let x=0;x<16;x++,e+=4)_e[x]=t.getUint32(e),Le[x]=t.getUint32(e+=4);for(let x=16;x<80;x++){const C=_e[x-15]|0,E=Le[x-15]|0,I=Q.rotrSH(C,E,1)^Q.rotrSH(C,E,8)^Q.shrSH(C,E,7),P=Q.rotrSL(C,E,1)^Q.rotrSL(C,E,8)^Q.shrSL(C,E,7),N=_e[x-2]|0,rt=Le[x-2]|0,X=Q.rotrSH(N,rt,19)^Q.rotrBH(N,rt,61)^Q.shrSH(N,rt,6),Z=Q.rotrSL(N,rt,19)^Q.rotrBL(N,rt,61)^Q.shrSL(N,rt,6),ht=Q.add4L(P,Z,Le[x-7],Le[x-16]),ut=Q.add4H(ht,I,X,_e[x-7],_e[x-16]);_e[x]=ut|0,Le[x]=ht|0}let{Ah:n,Al:i,Bh:o,Bl:s,Ch:a,Cl:c,Dh:u,Dl:l,Eh:h,El:y,Fh:f,Fl:p,Gh:d,Gl:g,Hh:S,Hl:B}=this;for(let x=0;x<80;x++){const C=Q.rotrSH(h,y,14)^Q.rotrSH(h,y,18)^Q.rotrBH(h,y,41),E=Q.rotrSL(h,y,14)^Q.rotrSL(h,y,18)^Q.rotrBL(h,y,41),I=h&f^~h&d,P=y&p^~y&g,N=Q.add5L(B,E,P,fc[x],Le[x]),rt=Q.add5H(N,S,C,I,dc[x],_e[x]),X=N|0,Z=Q.rotrSH(n,i,28)^Q.rotrBH(n,i,34)^Q.rotrBH(n,i,39),ht=Q.rotrSL(n,i,28)^Q.rotrBL(n,i,34)^Q.rotrBL(n,i,39),ut=n&o^n&a^o&a,Nt=i&s^i&c^s&c;S=d|0,B=g|0,d=f|0,g=p|0,f=h|0,p=y|0,{h,l:y}=Q.add(u|0,l|0,rt|0,X|0),u=a|0,l=c|0,a=o|0,c=s|0,o=n|0,s=i|0;const T=Q.add3L(X,ht,Nt);n=Q.add3H(T,rt,Z,ut),i=T|0}({h:n,l:i}=Q.add(this.Ah|0,this.Al|0,n|0,i|0)),{h:o,l:s}=Q.add(this.Bh|0,this.Bl|0,o|0,s|0),{h:a,l:c}=Q.add(this.Ch|0,this.Cl|0,a|0,c|0),{h:u,l}=Q.add(this.Dh|0,this.Dl|0,u|0,l|0),{h,l:y}=Q.add(this.Eh|0,this.El|0,h|0,y|0),{h:f,l:p}=Q.add(this.Fh|0,this.Fl|0,f|0,p|0),{h:d,l:g}=Q.add(this.Gh|0,this.Gl|0,d|0,g|0),{h:S,l:B}=Q.add(this.Hh|0,this.Hl|0,S|0,B|0),this.set(n,i,o,s,a,c,u,l,h,y,f,p,d,g,S,B)}roundClean(){_e.fill(0),Le.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const gc=fo(()=>new pc);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const mo=BigInt(0),Vr=BigInt(1),yc=BigInt(2);function je(r){return r instanceof Uint8Array||r!=null&&typeof r=="object"&&r.constructor.name==="Uint8Array"}function _r(r){if(!je(r))throw new Error("Uint8Array expected")}const mc=Array.from({length:256},(r,t)=>t.toString(16).padStart(2,"0"));function De(r){_r(r);let t="";for(let e=0;e<r.length;e++)t+=mc[r[e]];return t}function bo(r){const t=r.toString(16);return t.length&1?`0${t}`:t}function Fn(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return BigInt(r===""?"0":`0x${r}`)}const we={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function wo(r){if(r>=we._0&&r<=we._9)return r-we._0;if(r>=we._A&&r<=we._F)return r-(we._A-10);if(r>=we._a&&r<=we._f)return r-(we._a-10)}function or(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);const t=r.length,e=t/2;if(t%2)throw new Error("padded hex string expected, got unpadded hex of length "+t);const n=new Uint8Array(e);for(let i=0,o=0;i<e;i++,o+=2){const s=wo(r.charCodeAt(o)),a=wo(r.charCodeAt(o+1));if(s===void 0||a===void 0){const c=r[o]+r[o+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+o)}n[i]=s*16+a}return n}function Ve(r){return Fn(De(r))}function sr(r){return _r(r),Fn(De(Uint8Array.from(r).reverse()))}function ar(r,t){return or(r.toString(16).padStart(t*2,"0"))}function Lr(r,t){return ar(r,t).reverse()}function bc(r){return or(bo(r))}function Bt(r,t,e){let n;if(typeof t=="string")try{n=or(t)}catch(o){throw new Error(`${r} must be valid hex string, got "${t}". Cause: ${o}`)}else if(je(t))n=Uint8Array.from(t);else throw new Error(`${r} must be hex string or Uint8Array`);const i=n.length;if(typeof e=="number"&&i!==e)throw new Error(`${r} expected ${e} bytes, got ${i}`);return n}function Ge(...r){let t=0;for(let n=0;n<r.length;n++){const i=r[n];_r(i),t+=i.length}const e=new Uint8Array(t);for(let n=0,i=0;n<r.length;n++){const o=r[n];e.set(o,i),i+=o.length}return e}function wc(r,t){if(r.length!==t.length)return!1;let e=0;for(let n=0;n<r.length;n++)e|=r[n]^t[n];return e===0}function vc(r){if(typeof r!="string")throw new Error(`utf8ToBytes expected string, got ${typeof r}`);return new Uint8Array(new TextEncoder().encode(r))}function Sc(r){let t;for(t=0;r>mo;r>>=Vr,t+=1);return t}function xc(r,t){return r>>BigInt(t)&Vr}function Ec(r,t,e){return r|(e?Vr:mo)<<BigInt(t)}const Kn=r=>(yc<<BigInt(r-1))-Vr,Wn=r=>new Uint8Array(r),vo=r=>Uint8Array.from(r);function So(r,t,e){if(typeof r!="number"||r<2)throw new Error("hashLen must be a number");if(typeof t!="number"||t<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");let n=Wn(r),i=Wn(r),o=0;const s=()=>{n.fill(1),i.fill(0),o=0},a=(...l)=>e(i,n,...l),c=(l=Wn())=>{i=a(vo([0]),l),n=a(),l.length!==0&&(i=a(vo([1]),l),n=a())},u=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let l=0;const h=[];for(;l<t;){n=a();const y=n.slice();h.push(y),l+=n.length}return Ge(...h)};return(l,h)=>{s(),c(l);let y;for(;!(y=h(u()));)c();return s(),y}}const kc={bigint:r=>typeof r=="bigint",function:r=>typeof r=="function",boolean:r=>typeof r=="boolean",string:r=>typeof r=="string",stringOrUint8Array:r=>typeof r=="string"||je(r),isSafeInteger:r=>Number.isSafeInteger(r),array:r=>Array.isArray(r),field:(r,t)=>t.Fp.isValid(r),hash:r=>typeof r=="function"&&Number.isSafeInteger(r.outputLen)};function cr(r,t,e={}){const n=(i,o,s)=>{const a=kc[o];if(typeof a!="function")throw new Error(`Invalid validator "${o}", expected function`);const c=r[i];if(!(s&&c===void 0)&&!a(c,r))throw new Error(`Invalid param ${String(i)}=${c} (${typeof c}), expected ${o}`)};for(const[i,o]of Object.entries(t))n(i,o,!1);for(const[i,o]of Object.entries(e))n(i,o,!0);return r}const Bc=Object.freeze(Object.defineProperty({__proto__:null,abytes:_r,bitGet:xc,bitLen:Sc,bitMask:Kn,bitSet:Ec,bytesToHex:De,bytesToNumberBE:Ve,bytesToNumberLE:sr,concatBytes:Ge,createHmacDrbg:So,ensureBytes:Bt,equalBytes:wc,hexToBytes:or,hexToNumber:Fn,isBytes:je,numberToBytesBE:ar,numberToBytesLE:Lr,numberToHexUnpadded:bo,numberToVarBytesBE:bc,utf8ToBytes:vc,validateObject:cr},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const _t=BigInt(0),mt=BigInt(1),Ze=BigInt(2),Ac=BigInt(3),$n=BigInt(4),xo=BigInt(5),Eo=BigInt(8);BigInt(9),BigInt(16);function pt(r,t){const e=r%t;return e>=_t?e:t+e}function Ic(r,t,e){if(e<=_t||t<_t)throw new Error("Expected power/modulo > 0");if(e===mt)return _t;let n=mt;for(;t>_t;)t&mt&&(n=n*r%e),r=r*r%e,t>>=mt;return n}function St(r,t,e){let n=r;for(;t-- >_t;)n*=n,n%=e;return n}function Mn(r,t){if(r===_t||t<=_t)throw new Error(`invert: expected positive integers, got n=${r} mod=${t}`);let e=pt(r,t),n=t,i=_t,o=mt;for(;e!==_t;){const s=n/e,a=n%e,c=i-o*s;n=e,e=a,i=o,o=c}if(n!==mt)throw new Error("invert: does not exist");return pt(i,t)}function _c(r){const t=(r-mt)/Ze;let e,n,i;for(e=r-mt,n=0;e%Ze===_t;e/=Ze,n++);for(i=Ze;i<r&&Ic(i,t,r)!==r-mt;i++);if(n===1){const s=(r+mt)/$n;return function(a,c){const u=a.pow(c,s);if(!a.eql(a.sqr(u),c))throw new Error("Cannot find square root");return u}}const o=(e+mt)/Ze;return function(s,a){if(s.pow(a,t)===s.neg(s.ONE))throw new Error("Cannot find square root");let c=n,u=s.pow(s.mul(s.ONE,i),e),l=s.pow(a,o),h=s.pow(a,e);for(;!s.eql(h,s.ONE);){if(s.eql(h,s.ZERO))return s.ZERO;let y=1;for(let p=s.sqr(h);y<c&&!s.eql(p,s.ONE);y++)p=s.sqr(p);const f=s.pow(u,mt<<BigInt(c-y-1));u=s.sqr(f),l=s.mul(l,f),h=s.mul(h,u),c=y}return l}}function Lc(r){if(r%$n===Ac){const t=(r+mt)/$n;return function(e,n){const i=e.pow(n,t);if(!e.eql(e.sqr(i),n))throw new Error("Cannot find square root");return i}}if(r%Eo===xo){const t=(r-xo)/Eo;return function(e,n){const i=e.mul(n,Ze),o=e.pow(i,t),s=e.mul(n,o),a=e.mul(e.mul(s,Ze),o),c=e.mul(s,e.sub(a,e.ONE));if(!e.eql(e.sqr(c),n))throw new Error("Cannot find square root");return c}}return _c(r)}const Cc=(r,t)=>(pt(r,t)&mt)===mt,Tc=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Oc(r){const t={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=Tc.reduce((n,i)=>(n[i]="function",n),t);return cr(r,e)}function Pc(r,t,e){if(e<_t)throw new Error("Expected power > 0");if(e===_t)return r.ONE;if(e===mt)return t;let n=r.ONE,i=t;for(;e>_t;)e&mt&&(n=r.mul(n,i)),i=r.sqr(i),e>>=mt;return n}function Rc(r,t){const e=new Array(t.length),n=t.reduce((o,s,a)=>r.is0(s)?o:(e[a]=o,r.mul(o,s)),r.ONE),i=r.inv(n);return t.reduceRight((o,s,a)=>r.is0(s)?o:(e[a]=r.mul(o,e[a]),r.mul(o,s)),i),e}function ko(r,t){const e=t!==void 0?t:r.toString(2).length,n=Math.ceil(e/8);return{nBitLength:e,nByteLength:n}}function Bo(r,t,e=!1,n={}){if(r<=_t)throw new Error(`Expected Field ORDER > 0, got ${r}`);const{nBitLength:i,nByteLength:o}=ko(r,t);if(o>2048)throw new Error("Field lengths over 2048 bytes are not supported");const s=Lc(r),a=Object.freeze({ORDER:r,BITS:i,BYTES:o,MASK:Kn(i),ZERO:_t,ONE:mt,create:c=>pt(c,r),isValid:c=>{if(typeof c!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);return _t<=c&&c<r},is0:c=>c===_t,isOdd:c=>(c&mt)===mt,neg:c=>pt(-c,r),eql:(c,u)=>c===u,sqr:c=>pt(c*c,r),add:(c,u)=>pt(c+u,r),sub:(c,u)=>pt(c-u,r),mul:(c,u)=>pt(c*u,r),pow:(c,u)=>Pc(a,c,u),div:(c,u)=>pt(c*Mn(u,r),r),sqrN:c=>c*c,addN:(c,u)=>c+u,subN:(c,u)=>c-u,mulN:(c,u)=>c*u,inv:c=>Mn(c,r),sqrt:n.sqrt||(c=>s(a,c)),invertBatch:c=>Rc(a,c),cmov:(c,u,l)=>l?u:c,toBytes:c=>e?Lr(c,o):ar(c,o),fromBytes:c=>{if(c.length!==o)throw new Error(`Fp.fromBytes: expected ${o}, got ${c.length}`);return e?sr(c):Ve(c)}});return Object.freeze(a)}function Ao(r){if(typeof r!="bigint")throw new Error("field order must be bigint");const t=r.toString(2).length;return Math.ceil(t/8)}function Io(r){const t=Ao(r);return t+Math.ceil(t/2)}function Uc(r,t,e=!1){const n=r.length,i=Ao(t),o=Io(t);if(n<16||n<o||n>1024)throw new Error(`expected ${o}-1024 bytes of input, got ${n}`);const s=e?Ve(r):sr(r),a=pt(s,t-mt)+mt;return e?Lr(a,i):ar(a,i)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Nc=BigInt(0),jn=BigInt(1);function _o(r,t){const e=(i,o)=>{const s=o.negate();return i?s:o},n=i=>{const o=Math.ceil(t/i)+1,s=2**(i-1);return{windows:o,windowSize:s}};return{constTimeNegate:e,unsafeLadder(i,o){let s=r.ZERO,a=i;for(;o>Nc;)o&jn&&(s=s.add(a)),a=a.double(),o>>=jn;return s},precomputeWindow(i,o){const{windows:s,windowSize:a}=n(o),c=[];let u=i,l=u;for(let h=0;h<s;h++){l=u,c.push(l);for(let y=1;y<a;y++)l=l.add(u),c.push(l);u=l.double()}return c},wNAF(i,o,s){const{windows:a,windowSize:c}=n(i);let u=r.ZERO,l=r.BASE;const h=BigInt(2**i-1),y=2**i,f=BigInt(i);for(let p=0;p<a;p++){const d=p*c;let g=Number(s&h);s>>=f,g>c&&(g-=y,s+=jn);const S=d,B=d+Math.abs(g)-1,x=p%2!==0,C=g<0;g===0?l=l.add(e(x,o[S])):u=u.add(e(C,o[B]))}return{p:u,f:l}},wNAFCached(i,o,s,a){const c=i._WINDOW_SIZE||1;let u=o.get(i);return u||(u=this.precomputeWindow(i,c),c!==1&&o.set(i,a(u))),this.wNAF(c,u,s)}}}function Dn(r){return Oc(r.Fp),cr(r,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...ko(r.n,r.nBitLength),...r,p:r.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const se=BigInt(0),Vt=BigInt(1),Gr=BigInt(2),zc=BigInt(8),Hc={zip215:!0};function qc(r){const t=Dn(r);return cr(r,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...t})}function Fc(r){const t=qc(r),{Fp:e,n,prehash:i,hash:o,randomBytes:s,nByteLength:a,h:c}=t,u=Gr<<BigInt(a*8)-Vt,l=e.create,h=t.uvRatio||((v,m)=>{try{return{isValid:!0,value:e.sqrt(v*e.inv(m))}}catch{return{isValid:!1,value:se}}}),y=t.adjustScalarBytes||(v=>v),f=t.domain||((v,m,k)=>{if(m.length||k)throw new Error("Contexts/pre-hash are not supported");return v}),p=v=>typeof v=="bigint"&&se<v,d=(v,m)=>p(v)&&p(m)&&v<m,g=v=>v===se||d(v,u);function S(v,m){if(d(v,m))return v;throw new Error(`Expected valid scalar < ${m}, got ${typeof v} ${v}`)}function B(v){return v===se?v:S(v,n)}const x=new Map;function C(v){if(!(v instanceof E))throw new Error("ExtendedPoint expected")}class E{constructor(m,k,_,R){if(this.ex=m,this.ey=k,this.ez=_,this.et=R,!g(m))throw new Error("x required");if(!g(k))throw new Error("y required");if(!g(_))throw new Error("z required");if(!g(R))throw new Error("t required")}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(m){if(m instanceof E)throw new Error("extended point not allowed");const{x:k,y:_}=m||{};if(!g(k)||!g(_))throw new Error("invalid affine point");return new E(k,_,Vt,l(k*_))}static normalizeZ(m){const k=e.invertBatch(m.map(_=>_.ez));return m.map((_,R)=>_.toAffine(k[R])).map(E.fromAffine)}_setWindowSize(m){this._WINDOW_SIZE=m,x.delete(this)}assertValidity(){const{a:m,d:k}=t;if(this.is0())throw new Error("bad point: ZERO");const{ex:_,ey:R,ez:z,et:F}=this,D=l(_*_),K=l(R*R),V=l(z*z),J=l(V*V),st=l(D*m),dt=l(V*l(st+K)),ot=l(J+l(k*l(D*K)));if(dt!==ot)throw new Error("bad point: equation left != right (1)");const vt=l(_*R),ct=l(z*F);if(vt!==ct)throw new Error("bad point: equation left != right (2)")}equals(m){C(m);const{ex:k,ey:_,ez:R}=this,{ex:z,ey:F,ez:D}=m,K=l(k*D),V=l(z*R),J=l(_*D),st=l(F*R);return K===V&&J===st}is0(){return this.equals(E.ZERO)}negate(){return new E(l(-this.ex),this.ey,this.ez,l(-this.et))}double(){const{a:m}=t,{ex:k,ey:_,ez:R}=this,z=l(k*k),F=l(_*_),D=l(Gr*l(R*R)),K=l(m*z),V=k+_,J=l(l(V*V)-z-F),st=K+F,dt=st-D,ot=K-F,vt=l(J*dt),ct=l(st*ot),zt=l(J*ot),jt=l(dt*st);return new E(vt,ct,jt,zt)}add(m){C(m);const{a:k,d:_}=t,{ex:R,ey:z,ez:F,et:D}=this,{ex:K,ey:V,ez:J,et:st}=m;if(k===BigInt(-1)){const Sr=l((z-R)*(V+K)),xr=l((z+R)*(V-K)),Me=l(xr-Sr);if(Me===se)return this.double();const Er=l(F*Gr*st),kr=l(D*Gr*J),Br=kr+Er,Ar=xr+Sr,Ir=kr-Er,On=l(Br*Me),Pn=l(Ar*Ir),Rn=l(Br*Ir),Un=l(Me*Ar);return new E(On,Pn,Un,Rn)}const dt=l(R*K),ot=l(z*V),vt=l(D*_*st),ct=l(F*J),zt=l((R+z)*(K+V)-dt-ot),jt=ct-vt,Ae=ct+vt,Ie=l(ot-k*dt),_n=l(zt*jt),Ln=l(Ae*Ie),Cn=l(zt*Ie),Tn=l(jt*Ae);return new E(_n,Ln,Tn,Cn)}subtract(m){return this.add(m.negate())}wNAF(m){return N.wNAFCached(this,x,m,E.normalizeZ)}multiply(m){const{p:k,f:_}=this.wNAF(S(m,n));return E.normalizeZ([k,_])[0]}multiplyUnsafe(m){let k=B(m);return k===se?P:this.equals(P)||k===Vt?this:this.equals(I)?this.wNAF(k).p:N.unsafeLadder(this,k)}isSmallOrder(){return this.multiplyUnsafe(c).is0()}isTorsionFree(){return N.unsafeLadder(this,n).is0()}toAffine(m){const{ex:k,ey:_,ez:R}=this,z=this.is0();m==null&&(m=z?zc:e.inv(R));const F=l(k*m),D=l(_*m),K=l(R*m);if(z)return{x:se,y:Vt};if(K!==Vt)throw new Error("invZ was invalid");return{x:F,y:D}}clearCofactor(){const{h:m}=t;return m===Vt?this:this.multiplyUnsafe(m)}static fromHex(m,k=!1){const{d:_,a:R}=t,z=e.BYTES;m=Bt("pointHex",m,z);const F=m.slice(),D=m[z-1];F[z-1]=D&-129;const K=sr(F);K===se||(k?S(K,u):S(K,e.ORDER));const V=l(K*K),J=l(V-Vt),st=l(_*V-R);let{isValid:dt,value:ot}=h(J,st);if(!dt)throw new Error("Point.fromHex: invalid y coordinate");const vt=(ot&Vt)===Vt,ct=(D&128)!==0;if(!k&&ot===se&&ct)throw new Error("Point.fromHex: x=0 and x_0=1");return ct!==vt&&(ot=l(-ot)),E.fromAffine({x:ot,y:K})}static fromPrivateKey(m){return Z(m).point}toRawBytes(){const{x:m,y:k}=this.toAffine(),_=Lr(k,e.BYTES);return _[_.length-1]|=m&Vt?128:0,_}toHex(){return De(this.toRawBytes())}}E.BASE=new E(t.Gx,t.Gy,Vt,l(t.Gx*t.Gy)),E.ZERO=new E(se,Vt,Vt,se);const{BASE:I,ZERO:P}=E,N=_o(E,a*8);function rt(v){return pt(v,n)}function X(v){return rt(sr(v))}function Z(v){const m=a;v=Bt("private key",v,m);const k=Bt("hashed private key",o(v),2*m),_=y(k.slice(0,m)),R=k.slice(m,2*m),z=X(_),F=I.multiply(z),D=F.toRawBytes();return{head:_,prefix:R,scalar:z,point:F,pointBytes:D}}function ht(v){return Z(v).pointBytes}function ut(v=new Uint8Array,...m){const k=Ge(...m);return X(o(f(k,Bt("context",v),!!i)))}function Nt(v,m,k={}){v=Bt("message",v),i&&(v=i(v));const{prefix:_,scalar:R,pointBytes:z}=Z(m),F=ut(k.context,_,v),D=I.multiply(F).toRawBytes(),K=ut(k.context,D,z,v),V=rt(F+K*R);B(V);const J=Ge(D,Lr(V,e.BYTES));return Bt("result",J,a*2)}const T=Hc;function $(v,m,k,_=T){const{context:R,zip215:z}=_,F=e.BYTES;v=Bt("signature",v,2*F),m=Bt("message",m),i&&(m=i(m));const D=sr(v.slice(F,2*F));let K,V,J;try{K=E.fromHex(k,z),V=E.fromHex(v.slice(0,F),z),J=I.multiplyUnsafe(D)}catch{return!1}if(!z&&K.isSmallOrder())return!1;const st=ut(R,V.toRawBytes(),K.toRawBytes(),m);return V.add(K.multiplyUnsafe(st)).subtract(J).clearCofactor().equals(E.ZERO)}return I._setWindowSize(8),{CURVE:t,getPublicKey:ht,sign:Nt,verify:$,ExtendedPoint:E,utils:{getExtendedPublicKey:Z,randomPrivateKey:()=>s(e.BYTES),precompute(v=8,m=E.BASE){return m._setWindowSize(v),m.multiply(BigInt(3)),m}}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Vn=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),Lo=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");BigInt(0);const Kc=BigInt(1),Co=BigInt(2);BigInt(3);const Wc=BigInt(5),$c=BigInt(8);function Mc(r){const t=BigInt(10),e=BigInt(20),n=BigInt(40),i=BigInt(80),o=Vn,s=r*r%o*r%o,a=St(s,Co,o)*s%o,c=St(a,Kc,o)*r%o,u=St(c,Wc,o)*c%o,l=St(u,t,o)*u%o,h=St(l,e,o)*l%o,y=St(h,n,o)*h%o,f=St(y,i,o)*y%o,p=St(f,i,o)*y%o,d=St(p,t,o)*u%o;return{pow_p_5_8:St(d,Co,o)*r%o,b2:s}}function jc(r){return r[0]&=248,r[31]&=127,r[31]|=64,r}function Dc(r,t){const e=Vn,n=pt(t*t*t,e),i=pt(n*n*t,e),o=Mc(r*i).pow_p_5_8;let s=pt(r*n*o,e);const a=pt(t*s*s,e),c=s,u=pt(s*Lo,e),l=a===r,h=a===pt(-r,e),y=a===pt(-r*Lo,e);return l&&(s=c),(h||y)&&(s=u),Cc(s,e)&&(s=pt(-s,e)),{isValid:l||h,value:s}}const Vc=Bo(Vn,void 0,!0),Gc={a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:Vc,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:$c,Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:gc,randomBytes:po,adjustScalarBytes:jc,uvRatio:Dc},Cr=Fc(Gc);var Zr=ro.Buffer;function Zc(r){if(r.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),e=0;e<t.length;e++)t[e]=255;for(var n=0;n<r.length;n++){var i=r.charAt(n),o=i.charCodeAt(0);if(t[o]!==255)throw new TypeError(i+" is ambiguous");t[o]=n}var s=r.length,a=r.charAt(0),c=Math.log(s)/Math.log(256),u=Math.log(256)/Math.log(s);function l(f){if((Array.isArray(f)||f instanceof Uint8Array)&&(f=Zr.from(f)),!Zr.isBuffer(f))throw new TypeError("Expected Buffer");if(f.length===0)return"";for(var p=0,d=0,g=0,S=f.length;g!==S&&f[g]===0;)g++,p++;for(var B=(S-g)*u+1>>>0,x=new Uint8Array(B);g!==S;){for(var C=f[g],E=0,I=B-1;(C!==0||E<d)&&I!==-1;I--,E++)C+=256*x[I]>>>0,x[I]=C%s>>>0,C=C/s>>>0;if(C!==0)throw new Error("Non-zero carry");d=E,g++}for(var P=B-d;P!==B&&x[P]===0;)P++;for(var N=a.repeat(p);P<B;++P)N+=r.charAt(x[P]);return N}function h(f){if(typeof f!="string")throw new TypeError("Expected String");if(f.length===0)return Zr.alloc(0);for(var p=0,d=0,g=0;f[p]===a;)d++,p++;for(var S=(f.length-p)*c+1>>>0,B=new Uint8Array(S);f[p];){var x=t[f.charCodeAt(p)];if(x===255)return;for(var C=0,E=S-1;(x!==0||C<g)&&E!==-1;E--,C++)x+=s*B[E]>>>0,B[E]=x%256>>>0,x=x/256>>>0;if(x!==0)throw new Error("Non-zero carry");g=C,p++}for(var I=S-g;I!==S&&B[I]===0;)I++;var P=Zr.allocUnsafe(d+(S-I));P.fill(0,0,d);for(var N=d;I!==S;)P[N++]=B[I++];return P}function y(f){var p=h(f);if(p)return p;throw new Error("Non-base"+s+" character")}return{encode:l,decodeUnsafe:h,decode:y}}var Jc=Zc,Yc=Jc,Xc="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",Qc=Yc(Xc);const Ct=no(Qc),tu=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Ce=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Te=new Uint32Array(64);class eu extends go{constructor(){super(64,32,8,!1),this.A=Ce[0]|0,this.B=Ce[1]|0,this.C=Ce[2]|0,this.D=Ce[3]|0,this.E=Ce[4]|0,this.F=Ce[5]|0,this.G=Ce[6]|0,this.H=Ce[7]|0}get(){const{A:t,B:e,C:n,D:i,E:o,F:s,G:a,H:c}=this;return[t,e,n,i,o,s,a,c]}set(t,e,n,i,o,s,a,c){this.A=t|0,this.B=e|0,this.C=n|0,this.D=i|0,this.E=o|0,this.F=s|0,this.G=a|0,this.H=c|0}process(t,e){for(let h=0;h<16;h++,e+=4)Te[h]=t.getUint32(e,!1);for(let h=16;h<64;h++){const y=Te[h-15],f=Te[h-2],p=de(y,7)^de(y,18)^y>>>3,d=de(f,17)^de(f,19)^f>>>10;Te[h]=d+Te[h-7]+p+Te[h-16]|0}let{A:n,B:i,C:o,D:s,E:a,F:c,G:u,H:l}=this;for(let h=0;h<64;h++){const y=de(a,6)^de(a,11)^de(a,25),f=l+y+$a(a,c,u)+tu[h]+Te[h]|0,p=(de(n,2)^de(n,13)^de(n,22))+Ma(n,i,o)|0;l=u,u=c,c=a,a=s+f|0,s=o,o=i,i=n,n=f+p|0}n=n+this.A|0,i=i+this.B|0,o=o+this.C|0,s=s+this.D|0,a=a+this.E|0,c=c+this.F|0,u=u+this.G|0,l=l+this.H|0,this.set(n,i,o,s,a,c,u,l)}roundClean(){Te.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const Gn=fo(()=>new eu);var Tt={},Jr=ro.Buffer;function ru(r){if(r.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),e=0;e<t.length;e++)t[e]=255;for(var n=0;n<r.length;n++){var i=r.charAt(n),o=i.charCodeAt(0);if(t[o]!==255)throw new TypeError(i+" is ambiguous");t[o]=n}var s=r.length,a=r.charAt(0),c=Math.log(s)/Math.log(256),u=Math.log(256)/Math.log(s);function l(f){if((Array.isArray(f)||f instanceof Uint8Array)&&(f=Jr.from(f)),!Jr.isBuffer(f))throw new TypeError("Expected Buffer");if(f.length===0)return"";for(var p=0,d=0,g=0,S=f.length;g!==S&&f[g]===0;)g++,p++;for(var B=(S-g)*u+1>>>0,x=new Uint8Array(B);g!==S;){for(var C=f[g],E=0,I=B-1;(C!==0||E<d)&&I!==-1;I--,E++)C+=256*x[I]>>>0,x[I]=C%s>>>0,C=C/s>>>0;if(C!==0)throw new Error("Non-zero carry");d=E,g++}for(var P=B-d;P!==B&&x[P]===0;)P++;for(var N=a.repeat(p);P<B;++P)N+=r.charAt(x[P]);return N}function h(f){if(typeof f!="string")throw new TypeError("Expected String");if(f.length===0)return Jr.alloc(0);for(var p=0,d=0,g=0;f[p]===a;)d++,p++;for(var S=(f.length-p)*c+1>>>0,B=new Uint8Array(S);f[p];){var x=t[f.charCodeAt(p)];if(x===255)return;for(var C=0,E=S-1;(x!==0||C<g)&&E!==-1;E--,C++)x+=s*B[E]>>>0,B[E]=x%256>>>0,x=x/256>>>0;if(x!==0)throw new Error("Non-zero carry");g=C,p++}for(var I=S-g;I!==S&&B[I]===0;)I++;var P=Jr.allocUnsafe(d+(S-I));P.fill(0,0,d);for(var N=d;I!==S;)P[N++]=B[I++];return P}function y(f){var p=h(f);if(p)return p;throw new Error("Non-base"+s+" character")}return{encode:l,decodeUnsafe:h,decode:y}}var nu=ru,iu=nu,ou="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",su=iu(ou);function ve(r,t,e){return t<=r&&r<=e}function Yr(r){if(r===void 0)return{};if(r===Object(r))return r;throw TypeError("Could not convert argument to dictionary")}function au(r){for(var t=String(r),e=t.length,n=0,i=[];n<e;){var o=t.charCodeAt(n);if(o<55296||o>57343)i.push(o);else if(56320<=o&&o<=57343)i.push(65533);else if(55296<=o&&o<=56319)if(n===e-1)i.push(65533);else{var s=r.charCodeAt(n+1);if(56320<=s&&s<=57343){var a=o&1023,c=s&1023;i.push(65536+(a<<10)+c),n+=1}else i.push(65533)}n+=1}return i}function cu(r){for(var t="",e=0;e<r.length;++e){var n=r[e];n<=65535?t+=String.fromCharCode(n):(n-=65536,t+=String.fromCharCode((n>>10)+55296,(n&1023)+56320))}return t}var Xr=-1;function Zn(r){this.tokens=[].slice.call(r)}Zn.prototype={endOfStream:function(){return!this.tokens.length},read:function(){return this.tokens.length?this.tokens.shift():Xr},prepend:function(r){if(Array.isArray(r))for(var t=r;t.length;)this.tokens.unshift(t.pop());else this.tokens.unshift(r)},push:function(r){if(Array.isArray(r))for(var t=r;t.length;)this.tokens.push(t.shift());else this.tokens.push(r)}};var ur=-1;function Jn(r,t){if(r)throw TypeError("Decoder error");return t||65533}var Qr="utf-8";function tn(r,t){if(!(this instanceof tn))return new tn(r,t);if(r=r!==void 0?String(r).toLowerCase():Qr,r!==Qr)throw new Error("Encoding not supported. Only utf-8 is supported");t=Yr(t),this._streaming=!1,this._BOMseen=!1,this._decoder=null,this._fatal=!!t.fatal,this._ignoreBOM=!!t.ignoreBOM,Object.defineProperty(this,"encoding",{value:"utf-8"}),Object.defineProperty(this,"fatal",{value:this._fatal}),Object.defineProperty(this,"ignoreBOM",{value:this._ignoreBOM})}tn.prototype={decode:function(r,t){var e;typeof r=="object"&&r instanceof ArrayBuffer?e=new Uint8Array(r):typeof r=="object"&&"buffer"in r&&r.buffer instanceof ArrayBuffer?e=new Uint8Array(r.buffer,r.byteOffset,r.byteLength):e=new Uint8Array(0),t=Yr(t),this._streaming||(this._decoder=new uu({fatal:this._fatal}),this._BOMseen=!1),this._streaming=!!t.stream;for(var n=new Zn(e),i=[],o;!n.endOfStream()&&(o=this._decoder.handler(n,n.read()),o!==ur);)o!==null&&(Array.isArray(o)?i.push.apply(i,o):i.push(o));if(!this._streaming){do{if(o=this._decoder.handler(n,n.read()),o===ur)break;o!==null&&(Array.isArray(o)?i.push.apply(i,o):i.push(o))}while(!n.endOfStream());this._decoder=null}return i.length&&["utf-8"].indexOf(this.encoding)!==-1&&!this._ignoreBOM&&!this._BOMseen&&(i[0]===65279?(this._BOMseen=!0,i.shift()):this._BOMseen=!0),cu(i)}};function en(r,t){if(!(this instanceof en))return new en(r,t);if(r=r!==void 0?String(r).toLowerCase():Qr,r!==Qr)throw new Error("Encoding not supported. Only utf-8 is supported");t=Yr(t),this._streaming=!1,this._encoder=null,this._options={fatal:!!t.fatal},Object.defineProperty(this,"encoding",{value:"utf-8"})}en.prototype={encode:function(r,t){r=r?String(r):"",t=Yr(t),this._streaming||(this._encoder=new lu(this._options)),this._streaming=!!t.stream;for(var e=[],n=new Zn(au(r)),i;!n.endOfStream()&&(i=this._encoder.handler(n,n.read()),i!==ur);)Array.isArray(i)?e.push.apply(e,i):e.push(i);if(!this._streaming){for(;i=this._encoder.handler(n,n.read()),i!==ur;)Array.isArray(i)?e.push.apply(e,i):e.push(i);this._encoder=null}return new Uint8Array(e)}};function uu(r){var t=r.fatal,e=0,n=0,i=0,o=128,s=191;this.handler=function(a,c){if(c===Xr&&i!==0)return i=0,Jn(t);if(c===Xr)return ur;if(i===0){if(ve(c,0,127))return c;if(ve(c,194,223))i=1,e=c-192;else if(ve(c,224,239))c===224&&(o=160),c===237&&(s=159),i=2,e=c-224;else if(ve(c,240,244))c===240&&(o=144),c===244&&(s=143),i=3,e=c-240;else return Jn(t);return e=e<<6*i,null}if(!ve(c,o,s))return e=i=n=0,o=128,s=191,a.prepend(c),Jn(t);if(o=128,s=191,n+=1,e+=c-128<<6*(i-n),n!==i)return null;var u=e;return e=i=n=0,u}}function lu(r){r.fatal,this.handler=function(t,e){if(e===Xr)return ur;if(ve(e,0,127))return e;var n,i;ve(e,128,2047)?(n=1,i=192):ve(e,2048,65535)?(n=2,i=224):ve(e,65536,1114111)&&(n=3,i=240);for(var o=[(e>>6*n)+i];n>0;){var s=e>>6*(n-1);o.push(128|s&63),n-=1}return o}}const hu=Object.freeze(Object.defineProperty({__proto__:null,TextDecoder:tn,TextEncoder:en},Symbol.toStringTag,{value:"Module"})),du=io(hu);var fu=he&&he.__createBinding||(Object.create?function(r,t,e,n){n===void 0&&(n=e),Object.defineProperty(r,n,{enumerable:!0,get:function(){return t[e]}})}:function(r,t,e,n){n===void 0&&(n=e),r[n]=t[e]}),pu=he&&he.__setModuleDefault||(Object.create?function(r,t){Object.defineProperty(r,"default",{enumerable:!0,value:t})}:function(r,t){r.default=t}),fe=he&&he.__decorate||function(r,t,e,n){var i=arguments.length,o=i<3?t:n===null?n=Object.getOwnPropertyDescriptor(t,e):n,s;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")o=Reflect.decorate(r,t,e,n);else for(var a=r.length-1;a>=0;a--)(s=r[a])&&(o=(i<3?s(o):i>3?s(t,e,o):s(t,e))||o);return i>3&&o&&Object.defineProperty(t,e,o),o},gu=he&&he.__importStar||function(r){if(r&&r.__esModule)return r;var t={};if(r!=null)for(var e in r)e!=="default"&&Object.hasOwnProperty.call(r,e)&&fu(t,r,e);return pu(t,r),t},To=he&&he.__importDefault||function(r){return r&&r.__esModule?r:{default:r}};Object.defineProperty(Tt,"__esModule",{value:!0});var Oo=Tt.deserializeUnchecked=Ho=Tt.deserialize=zo=Tt.serialize=Tt.BinaryReader=Tt.BinaryWriter=Tt.BorshError=Tt.baseDecode=Tt.baseEncode=void 0;const Oe=To(Ta()),Po=To(su),yu=gu(du),mu=typeof TextDecoder!="function"?yu.TextDecoder:TextDecoder,bu=new mu("utf-8",{fatal:!0});function wu(r){return typeof r=="string"&&(r=yt.from(r,"utf8")),Po.default.encode(yt.from(r))}Tt.baseEncode=wu;function vu(r){return yt.from(Po.default.decode(r))}Tt.baseDecode=vu;const Yn=1024;class Wt extends Error{constructor(t){super(t),this.fieldPath=[],this.originalMessage=t}addToFieldPath(t){this.fieldPath.splice(0,0,t),this.message=this.originalMessage+": "+this.fieldPath.join(".")}}Tt.BorshError=Wt;class Ro{constructor(){this.buf=yt.alloc(Yn),this.length=0}maybeResize(){this.buf.length<16+this.length&&(this.buf=yt.concat([this.buf,yt.alloc(Yn)]))}writeU8(t){this.maybeResize(),this.buf.writeUInt8(t,this.length),this.length+=1}writeU16(t){this.maybeResize(),this.buf.writeUInt16LE(t,this.length),this.length+=2}writeU32(t){this.maybeResize(),this.buf.writeUInt32LE(t,this.length),this.length+=4}writeU64(t){this.maybeResize(),this.writeBuffer(yt.from(new Oe.default(t).toArray("le",8)))}writeU128(t){this.maybeResize(),this.writeBuffer(yt.from(new Oe.default(t).toArray("le",16)))}writeU256(t){this.maybeResize(),this.writeBuffer(yt.from(new Oe.default(t).toArray("le",32)))}writeU512(t){this.maybeResize(),this.writeBuffer(yt.from(new Oe.default(t).toArray("le",64)))}writeBuffer(t){this.buf=yt.concat([yt.from(this.buf.subarray(0,this.length)),t,yt.alloc(Yn)]),this.length+=t.length}writeString(t){this.maybeResize();const e=yt.from(t,"utf8");this.writeU32(e.length),this.writeBuffer(e)}writeFixedArray(t){this.writeBuffer(yt.from(t))}writeArray(t,e){this.maybeResize(),this.writeU32(t.length);for(const n of t)this.maybeResize(),e(n)}toArray(){return this.buf.subarray(0,this.length)}}Tt.BinaryWriter=Ro;function pe(r,t,e){const n=e.value;e.value=function(...i){try{return n.apply(this,i)}catch(o){if(o instanceof RangeError){const s=o.code;if(["ERR_BUFFER_OUT_OF_BOUNDS","ERR_OUT_OF_RANGE"].indexOf(s)>=0)throw new Wt("Reached the end of buffer when deserializing")}throw o}}}class Gt{constructor(t){this.buf=t,this.offset=0}readU8(){const t=this.buf.readUInt8(this.offset);return this.offset+=1,t}readU16(){const t=this.buf.readUInt16LE(this.offset);return this.offset+=2,t}readU32(){const t=this.buf.readUInt32LE(this.offset);return this.offset+=4,t}readU64(){const t=this.readBuffer(8);return new Oe.default(t,"le")}readU128(){const t=this.readBuffer(16);return new Oe.default(t,"le")}readU256(){const t=this.readBuffer(32);return new Oe.default(t,"le")}readU512(){const t=this.readBuffer(64);return new Oe.default(t,"le")}readBuffer(t){if(this.offset+t>this.buf.length)throw new Wt(`Expected buffer length ${t} isn't within bounds`);const e=this.buf.slice(this.offset,this.offset+t);return this.offset+=t,e}readString(){const t=this.readU32(),e=this.readBuffer(t);try{return bu.decode(e)}catch(n){throw new Wt(`Error decoding UTF-8 string: ${n}`)}}readFixedArray(t){return new Uint8Array(this.readBuffer(t))}readArray(t){const e=this.readU32(),n=Array();for(let i=0;i<e;++i)n.push(t());return n}}fe([pe],Gt.prototype,"readU8",null),fe([pe],Gt.prototype,"readU16",null),fe([pe],Gt.prototype,"readU32",null),fe([pe],Gt.prototype,"readU64",null),fe([pe],Gt.prototype,"readU128",null),fe([pe],Gt.prototype,"readU256",null),fe([pe],Gt.prototype,"readU512",null),fe([pe],Gt.prototype,"readString",null),fe([pe],Gt.prototype,"readFixedArray",null),fe([pe],Gt.prototype,"readArray",null),Tt.BinaryReader=Gt;function Uo(r){return r.charAt(0).toUpperCase()+r.slice(1)}function Je(r,t,e,n,i){try{if(typeof n=="string")i[`write${Uo(n)}`](e);else if(n instanceof Array)if(typeof n[0]=="number"){if(e.length!==n[0])throw new Wt(`Expecting byte array of length ${n[0]}, but got ${e.length} bytes`);i.writeFixedArray(e)}else if(n.length===2&&typeof n[1]=="number"){if(e.length!==n[1])throw new Wt(`Expecting byte array of length ${n[1]}, but got ${e.length} bytes`);for(let o=0;o<n[1];o++)Je(r,null,e[o],n[0],i)}else i.writeArray(e,o=>{Je(r,t,o,n[0],i)});else if(n.kind!==void 0)switch(n.kind){case"option":{e==null?i.writeU8(0):(i.writeU8(1),Je(r,t,e,n.type,i));break}case"map":{i.writeU32(e.size),e.forEach((o,s)=>{Je(r,t,s,n.key,i),Je(r,t,o,n.value,i)});break}default:throw new Wt(`FieldType ${n} unrecognized`)}else No(r,e,i)}catch(o){throw o instanceof Wt&&o.addToFieldPath(t),o}}function No(r,t,e){if(typeof t.borshSerialize=="function"){t.borshSerialize(e);return}const n=r.get(t.constructor);if(!n)throw new Wt(`Class ${t.constructor.name} is missing in schema`);if(n.kind==="struct")n.fields.map(([i,o])=>{Je(r,i,t[i],o,e)});else if(n.kind==="enum"){const i=t[n.field];for(let o=0;o<n.values.length;++o){const[s,a]=n.values[o];if(s===i){e.writeU8(o),Je(r,s,t[s],a,e);break}}}else throw new Wt(`Unexpected schema kind: ${n.kind} for ${t.constructor.name}`)}function Su(r,t,e=Ro){const n=new e;return No(r,t,n),n.toArray()}var zo=Tt.serialize=Su;function Ye(r,t,e,n){try{if(typeof e=="string")return n[`read${Uo(e)}`]();if(e instanceof Array){if(typeof e[0]=="number")return n.readFixedArray(e[0]);if(typeof e[1]=="number"){const i=[];for(let o=0;o<e[1];o++)i.push(Ye(r,null,e[0],n));return i}else return n.readArray(()=>Ye(r,t,e[0],n))}if(e.kind==="option")return n.readU8()?Ye(r,t,e.type,n):void 0;if(e.kind==="map"){let i=new Map;const o=n.readU32();for(let s=0;s<o;s++){const a=Ye(r,t,e.key,n),c=Ye(r,t,e.value,n);i.set(a,c)}return i}return Xn(r,e,n)}catch(i){throw i instanceof Wt&&i.addToFieldPath(t),i}}function Xn(r,t,e){if(typeof t.borshDeserialize=="function")return t.borshDeserialize(e);const n=r.get(t);if(!n)throw new Wt(`Class ${t.name} is missing in schema`);if(n.kind==="struct"){const i={};for(const[o,s]of r.get(t).fields)i[o]=Ye(r,o,s,e);return new t(i)}if(n.kind==="enum"){const i=e.readU8();if(i>=n.values.length)throw new Wt(`Enum index: ${i} is out of range`);const[o,s]=n.values[i],a=Ye(r,o,s,e);return new t({[o]:a})}throw new Wt(`Unexpected schema kind: ${n.kind} for ${t.constructor.name}`)}function xu(r,t,e,n=Gt){const i=new n(e),o=Xn(r,t,i);if(i.offset<e.length)throw new Wt(`Unexpected ${e.length-i.offset} bytes after deserialized data`);return o}var Ho=Tt.deserialize=xu;function Eu(r,t,e,n=Gt){const i=new n(e);return Xn(r,t,i)}Oo=Tt.deserializeUnchecked=Eu;var w={};Object.defineProperty(w,"__esModule",{value:!0}),w.s16=w.s8=w.nu64be=w.u48be=w.u40be=w.u32be=w.u24be=w.u16be=Ot=w.nu64=w.u48=w.u40=j=w.u32=w.u24=Qt=w.u16=nt=w.u8=Qe=w.offset=w.greedy=w.Constant=w.UTF8=w.CString=w.Blob=w.Boolean=w.BitField=w.BitStructure=w.VariantLayout=w.Union=w.UnionLayoutDiscriminator=w.UnionDiscriminator=w.Structure=w.Sequence=w.DoubleBE=w.Double=w.FloatBE=w.Float=w.NearInt64BE=w.NearInt64=w.NearUInt64BE=w.NearUInt64=w.IntBE=w.Int=w.UIntBE=w.UInt=w.OffsetLayout=w.GreedyCount=w.ExternalLayout=w.bindConstructorLayout=w.nameWithProperty=w.Layout=w.uint8ArrayToBuffer=w.checkUint8Array=void 0,w.constant=w.utf8=w.cstr=gt=w.blob=w.unionLayoutDiscriminator=w.union=$t=w.seq=w.bits=W=w.struct=w.f64be=w.f64=w.f32be=w.f32=w.ns64be=w.s48be=w.s40be=w.s32be=w.s24be=w.s16be=Zt=w.ns64=w.s48=w.s40=w.s32=w.s24=void 0;const Qn=Oa;function lr(r){if(!(r instanceof Uint8Array))throw new TypeError("b must be a Uint8Array")}w.checkUint8Array=lr;function at(r){return lr(r),Qn.Buffer.from(r.buffer,r.byteOffset,r.length)}w.uint8ArrayToBuffer=at;class lt{constructor(t,e){if(!Number.isInteger(t))throw new TypeError("span must be an integer");this.span=t,this.property=e}makeDestinationObject(){return{}}getSpan(t,e){if(0>this.span)throw new RangeError("indeterminate span");return this.span}replicate(t){const e=Object.create(this.constructor.prototype);return Object.assign(e,this),e.property=t,e}fromArray(t){}}w.Layout=lt;function ti(r,t){return t.property?r+"["+t.property+"]":r}w.nameWithProperty=ti;function ku(r,t){if(typeof r!="function")throw new TypeError("Class must be constructor");if(Object.prototype.hasOwnProperty.call(r,"layout_"))throw new Error("Class is already bound to a layout");if(!(t&&t instanceof lt))throw new TypeError("layout must be a Layout");if(Object.prototype.hasOwnProperty.call(t,"boundConstructor_"))throw new Error("layout is already bound to a constructor");r.layout_=t,t.boundConstructor_=r,t.makeDestinationObject=()=>new r,Object.defineProperty(r.prototype,"encode",{value(e,n){return t.encode(this,e,n)},writable:!0}),Object.defineProperty(r,"decode",{value(e,n){return t.decode(e,n)},writable:!0})}w.bindConstructorLayout=ku;class Dt extends lt{isCount(){throw new Error("ExternalLayout is abstract")}}w.ExternalLayout=Dt;class qo extends Dt{constructor(t=1,e){if(!Number.isInteger(t)||0>=t)throw new TypeError("elementSpan must be a (positive) integer");super(-1,e),this.elementSpan=t}isCount(){return!0}decode(t,e=0){lr(t);const n=t.length-e;return Math.floor(n/this.elementSpan)}encode(t,e,n){return 0}}w.GreedyCount=qo;class ei extends Dt{constructor(t,e=0,n){if(!(t instanceof lt))throw new TypeError("layout must be a Layout");if(!Number.isInteger(e))throw new TypeError("offset must be integer or undefined");super(t.span,n||t.property),this.layout=t,this.offset=e}isCount(){return this.layout instanceof Xt||this.layout instanceof ae}decode(t,e=0){return this.layout.decode(t,e+this.offset)}encode(t,e,n=0){return this.layout.encode(t,e,n+this.offset)}}w.OffsetLayout=ei;class Xt extends lt{constructor(t,e){if(super(t,e),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(t,e=0){return at(t).readUIntLE(e,this.span)}encode(t,e,n=0){return at(e).writeUIntLE(t,n,this.span),this.span}}w.UInt=Xt;class ae extends lt{constructor(t,e){if(super(t,e),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(t,e=0){return at(t).readUIntBE(e,this.span)}encode(t,e,n=0){return at(e).writeUIntBE(t,n,this.span),this.span}}w.UIntBE=ae;class Xe extends lt{constructor(t,e){if(super(t,e),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(t,e=0){return at(t).readIntLE(e,this.span)}encode(t,e,n=0){return at(e).writeIntLE(t,n,this.span),this.span}}w.Int=Xe;class hr extends lt{constructor(t,e){if(super(t,e),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(t,e=0){return at(t).readIntBE(e,this.span)}encode(t,e,n=0){return at(e).writeIntBE(t,n,this.span),this.span}}w.IntBE=hr;const ri=Math.pow(2,32);function rn(r){const t=Math.floor(r/ri),e=r-t*ri;return{hi32:t,lo32:e}}function nn(r,t){return r*ri+t}class Fo extends lt{constructor(t){super(8,t)}decode(t,e=0){const n=at(t),i=n.readUInt32LE(e),o=n.readUInt32LE(e+4);return nn(o,i)}encode(t,e,n=0){const i=rn(t),o=at(e);return o.writeUInt32LE(i.lo32,n),o.writeUInt32LE(i.hi32,n+4),8}}w.NearUInt64=Fo;class Ko extends lt{constructor(t){super(8,t)}decode(t,e=0){const n=at(t),i=n.readUInt32BE(e),o=n.readUInt32BE(e+4);return nn(i,o)}encode(t,e,n=0){const i=rn(t),o=at(e);return o.writeUInt32BE(i.hi32,n),o.writeUInt32BE(i.lo32,n+4),8}}w.NearUInt64BE=Ko;class Wo extends lt{constructor(t){super(8,t)}decode(t,e=0){const n=at(t),i=n.readUInt32LE(e),o=n.readInt32LE(e+4);return nn(o,i)}encode(t,e,n=0){const i=rn(t),o=at(e);return o.writeUInt32LE(i.lo32,n),o.writeInt32LE(i.hi32,n+4),8}}w.NearInt64=Wo;class $o extends lt{constructor(t){super(8,t)}decode(t,e=0){const n=at(t),i=n.readInt32BE(e),o=n.readUInt32BE(e+4);return nn(i,o)}encode(t,e,n=0){const i=rn(t),o=at(e);return o.writeInt32BE(i.hi32,n),o.writeUInt32BE(i.lo32,n+4),8}}w.NearInt64BE=$o;class Mo extends lt{constructor(t){super(4,t)}decode(t,e=0){return at(t).readFloatLE(e)}encode(t,e,n=0){return at(e).writeFloatLE(t,n),4}}w.Float=Mo;class jo extends lt{constructor(t){super(4,t)}decode(t,e=0){return at(t).readFloatBE(e)}encode(t,e,n=0){return at(e).writeFloatBE(t,n),4}}w.FloatBE=jo;class Do extends lt{constructor(t){super(8,t)}decode(t,e=0){return at(t).readDoubleLE(e)}encode(t,e,n=0){return at(e).writeDoubleLE(t,n),8}}w.Double=Do;class Vo extends lt{constructor(t){super(8,t)}decode(t,e=0){return at(t).readDoubleBE(e)}encode(t,e,n=0){return at(e).writeDoubleBE(t,n),8}}w.DoubleBE=Vo;class Go extends lt{constructor(t,e,n){if(!(t instanceof lt))throw new TypeError("elementLayout must be a Layout");if(!(e instanceof Dt&&e.isCount()||Number.isInteger(e)&&0<=e))throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");let i=-1;!(e instanceof Dt)&&0<t.span&&(i=e*t.span),super(i,n),this.elementLayout=t,this.count=e}getSpan(t,e=0){if(0<=this.span)return this.span;let n=0,i=this.count;if(i instanceof Dt&&(i=i.decode(t,e)),0<this.elementLayout.span)n=i*this.elementLayout.span;else{let o=0;for(;o<i;)n+=this.elementLayout.getSpan(t,e+n),++o}return n}decode(t,e=0){const n=[];let i=0,o=this.count;for(o instanceof Dt&&(o=o.decode(t,e));i<o;)n.push(this.elementLayout.decode(t,e)),e+=this.elementLayout.getSpan(t,e),i+=1;return n}encode(t,e,n=0){const i=this.elementLayout,o=t.reduce((s,a)=>s+i.encode(a,e,n+s),0);return this.count instanceof Dt&&this.count.encode(t.length,e,n),o}}w.Sequence=Go;class Zo extends lt{constructor(t,e,n){if(!(Array.isArray(t)&&t.reduce((o,s)=>o&&s instanceof lt,!0)))throw new TypeError("fields must be array of Layout instances");typeof e=="boolean"&&n===void 0&&(n=e,e=void 0);for(const o of t)if(0>o.span&&o.property===void 0)throw new Error("fields cannot contain unnamed variable-length layout");let i=-1;try{i=t.reduce((o,s)=>o+s.getSpan(),0)}catch{}super(i,e),this.fields=t,this.decodePrefixes=!!n}getSpan(t,e=0){if(0<=this.span)return this.span;let n=0;try{n=this.fields.reduce((i,o)=>{const s=o.getSpan(t,e);return e+=s,i+s},0)}catch{throw new RangeError("indeterminate span")}return n}decode(t,e=0){lr(t);const n=this.makeDestinationObject();for(const i of this.fields)if(i.property!==void 0&&(n[i.property]=i.decode(t,e)),e+=i.getSpan(t,e),this.decodePrefixes&&t.length===e)break;return n}encode(t,e,n=0){const i=n;let o=0,s=0;for(const a of this.fields){let c=a.span;if(s=0<c?c:0,a.property!==void 0){const u=t[a.property];u!==void 0&&(s=a.encode(u,e,n),0>c&&(c=a.getSpan(e,n)))}o=n,n+=c}return o+s-i}fromArray(t){const e=this.makeDestinationObject();for(const n of this.fields)n.property!==void 0&&0<t.length&&(e[n.property]=t.shift());return e}layoutFor(t){if(typeof t!="string")throw new TypeError("property must be string");for(const e of this.fields)if(e.property===t)return e}offsetOf(t){if(typeof t!="string")throw new TypeError("property must be string");let e=0;for(const n of this.fields){if(n.property===t)return e;0>n.span?e=-1:0<=e&&(e+=n.span)}}}w.Structure=Zo;class ni{constructor(t){this.property=t}decode(t,e){throw new Error("UnionDiscriminator is abstract")}encode(t,e,n){throw new Error("UnionDiscriminator is abstract")}}w.UnionDiscriminator=ni;class on extends ni{constructor(t,e){if(!(t instanceof Dt&&t.isCount()))throw new TypeError("layout must be an unsigned integer ExternalLayout");super(e||t.property||"variant"),this.layout=t}decode(t,e){return this.layout.decode(t,e)}encode(t,e,n){return this.layout.encode(t,e,n)}}w.UnionLayoutDiscriminator=on;class ii extends lt{constructor(t,e,n){let i;if(t instanceof Xt||t instanceof ae)i=new on(new ei(t));else if(t instanceof Dt&&t.isCount())i=new on(t);else if(t instanceof ni)i=t;else throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");if(e===void 0&&(e=null),!(e===null||e instanceof lt))throw new TypeError("defaultLayout must be null or a Layout");if(e!==null){if(0>e.span)throw new Error("defaultLayout must have constant span");e.property===void 0&&(e=e.replicate("content"))}let o=-1;e&&(o=e.span,0<=o&&(t instanceof Xt||t instanceof ae)&&(o+=i.layout.span)),super(o,n),this.discriminator=i,this.usesPrefixDiscriminator=t instanceof Xt||t instanceof ae,this.defaultLayout=e,this.registry={};let s=this.defaultGetSourceVariant.bind(this);this.getSourceVariant=function(a){return s(a)},this.configGetSourceVariant=function(a){s=a.bind(this)}}getSpan(t,e=0){if(0<=this.span)return this.span;const n=this.getVariant(t,e);if(!n)throw new Error("unable to determine span for unrecognized variant");return n.getSpan(t,e)}defaultGetSourceVariant(t){if(Object.prototype.hasOwnProperty.call(t,this.discriminator.property)){if(this.defaultLayout&&this.defaultLayout.property&&Object.prototype.hasOwnProperty.call(t,this.defaultLayout.property))return;const e=this.registry[t[this.discriminator.property]];if(e&&(!e.layout||e.property&&Object.prototype.hasOwnProperty.call(t,e.property)))return e}else for(const e in this.registry){const n=this.registry[e];if(n.property&&Object.prototype.hasOwnProperty.call(t,n.property))return n}throw new Error("unable to infer src variant")}decode(t,e=0){let n;const i=this.discriminator,o=i.decode(t,e),s=this.registry[o];if(s===void 0){const a=this.defaultLayout;let c=0;this.usesPrefixDiscriminator&&(c=i.layout.span),n=this.makeDestinationObject(),n[i.property]=o,n[a.property]=a.decode(t,e+c)}else n=s.decode(t,e);return n}encode(t,e,n=0){const i=this.getSourceVariant(t);if(i===void 0){const o=this.discriminator,s=this.defaultLayout;let a=0;return this.usesPrefixDiscriminator&&(a=o.layout.span),o.encode(t[o.property],e,n),a+s.encode(t[s.property],e,n+a)}return i.encode(t,e,n)}addVariant(t,e,n){const i=new Jo(this,t,e,n);return this.registry[t]=i,i}getVariant(t,e=0){let n;return t instanceof Uint8Array?n=this.discriminator.decode(t,e):n=t,this.registry[n]}}w.Union=ii;class Jo extends lt{constructor(t,e,n,i){if(!(t instanceof ii))throw new TypeError("union must be a Union");if(!Number.isInteger(e)||0>e)throw new TypeError("variant must be a (non-negative) integer");if(typeof n=="string"&&i===void 0&&(i=n,n=null),n){if(!(n instanceof lt))throw new TypeError("layout must be a Layout");if(t.defaultLayout!==null&&0<=n.span&&n.span>t.defaultLayout.span)throw new Error("variant span exceeds span of containing union");if(typeof i!="string")throw new TypeError("variant must have a String property")}let o=t.span;0>t.span&&(o=n?n.span:0,0<=o&&t.usesPrefixDiscriminator&&(o+=t.discriminator.layout.span)),super(o,i),this.union=t,this.variant=e,this.layout=n||null}getSpan(t,e=0){if(0<=this.span)return this.span;let n=0;this.union.usesPrefixDiscriminator&&(n=this.union.discriminator.layout.span);let i=0;return this.layout&&(i=this.layout.getSpan(t,e+n)),n+i}decode(t,e=0){const n=this.makeDestinationObject();if(this!==this.union.getVariant(t,e))throw new Error("variant mismatch");let i=0;return this.union.usesPrefixDiscriminator&&(i=this.union.discriminator.layout.span),this.layout?n[this.property]=this.layout.decode(t,e+i):this.property?n[this.property]=!0:this.union.usesPrefixDiscriminator&&(n[this.union.discriminator.property]=this.variant),n}encode(t,e,n=0){let i=0;if(this.union.usesPrefixDiscriminator&&(i=this.union.discriminator.layout.span),this.layout&&!Object.prototype.hasOwnProperty.call(t,this.property))throw new TypeError("variant lacks property "+this.property);this.union.discriminator.encode(this.variant,e,n);let o=i;if(this.layout&&(this.layout.encode(t[this.property],e,n+i),o+=this.layout.getSpan(e,n+i),0<=this.union.span&&o>this.union.span))throw new Error("encoded variant overruns containing union");return o}fromArray(t){if(this.layout)return this.layout.fromArray(t)}}w.VariantLayout=Jo;function dr(r){return 0>r&&(r+=4294967296),r}class oi extends lt{constructor(t,e,n){if(!(t instanceof Xt||t instanceof ae))throw new TypeError("word must be a UInt or UIntBE layout");if(typeof e=="string"&&n===void 0&&(n=e,e=!1),4<t.span)throw new RangeError("word cannot exceed 32 bits");super(t.span,n),this.word=t,this.msb=!!e,this.fields=[];let i=0;this._packedSetValue=function(o){return i=dr(o),this},this._packedGetValue=function(){return i}}decode(t,e=0){const n=this.makeDestinationObject(),i=this.word.decode(t,e);this._packedSetValue(i);for(const o of this.fields)o.property!==void 0&&(n[o.property]=o.decode(t));return n}encode(t,e,n=0){const i=this.word.decode(e,n);this._packedSetValue(i);for(const o of this.fields)if(o.property!==void 0){const s=t[o.property];s!==void 0&&o.encode(s)}return this.word.encode(this._packedGetValue(),e,n)}addField(t,e){const n=new si(this,t,e);return this.fields.push(n),n}addBoolean(t){const e=new Yo(this,t);return this.fields.push(e),e}fieldFor(t){if(typeof t!="string")throw new TypeError("property must be string");for(const e of this.fields)if(e.property===t)return e}}w.BitStructure=oi;class si{constructor(t,e,n){if(!(t instanceof oi))throw new TypeError("container must be a BitStructure");if(!Number.isInteger(e)||0>=e)throw new TypeError("bits must be positive integer");const i=8*t.span,o=t.fields.reduce((s,a)=>s+a.bits,0);if(e+o>i)throw new Error("bits too long for span remainder ("+(i-o)+" of "+i+" remain)");this.container=t,this.bits=e,this.valueMask=(1<<e)-1,e===32&&(this.valueMask=4294967295),this.start=o,this.container.msb&&(this.start=i-o-e),this.wordMask=dr(this.valueMask<<this.start),this.property=n}decode(t,e){const n=this.container._packedGetValue();return dr(n&this.wordMask)>>>this.start}encode(t){if(typeof t!="number"||!Number.isInteger(t)||t!==dr(t&this.valueMask))throw new TypeError(ti("BitField.encode",this)+" value must be integer not exceeding "+this.valueMask);const e=this.container._packedGetValue(),n=dr(t<<this.start);this.container._packedSetValue(dr(e&~this.wordMask)|n)}}w.BitField=si;let Yo=class extends si{constructor(r,t){super(r,1,t)}decode(r,t){return!!super.decode(r,t)}encode(r){typeof r=="boolean"&&(r=+r),super.encode(r)}};w.Boolean=Yo;class Xo extends lt{constructor(t,e){if(!(t instanceof Dt&&t.isCount()||Number.isInteger(t)&&0<=t))throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");let n=-1;t instanceof Dt||(n=t),super(n,e),this.length=t}getSpan(t,e){let n=this.span;return 0>n&&(n=this.length.decode(t,e)),n}decode(t,e=0){let n=this.span;return 0>n&&(n=this.length.decode(t,e)),at(t).slice(e,e+n)}encode(t,e,n){let i=this.length;if(this.length instanceof Dt&&(i=t.length),!(t instanceof Uint8Array&&i===t.length))throw new TypeError(ti("Blob.encode",this)+" requires (length "+i+") Uint8Array as src");if(n+i>e.length)throw new RangeError("encoding overruns Uint8Array");const o=at(t);return at(e).write(o.toString("hex"),n,i,"hex"),this.length instanceof Dt&&this.length.encode(i,e,n),i}}w.Blob=Xo;class Qo extends lt{constructor(t){super(-1,t)}getSpan(t,e=0){lr(t);let n=e;for(;n<t.length&&t[n]!==0;)n+=1;return 1+n-e}decode(t,e=0){const n=this.getSpan(t,e);return at(t).slice(e,e+n-1).toString("utf-8")}encode(t,e,n=0){typeof t!="string"&&(t=String(t));const i=Qn.Buffer.from(t,"utf8"),o=i.length;if(n+o>e.length)throw new RangeError("encoding overruns Buffer");const s=at(e);return i.copy(s,n),s[n+o]=0,o+1}}w.CString=Qo;class ts extends lt{constructor(t,e){if(typeof t=="string"&&e===void 0&&(e=t,t=void 0),t===void 0)t=-1;else if(!Number.isInteger(t))throw new TypeError("maxSpan must be an integer");super(-1,e),this.maxSpan=t}getSpan(t,e=0){return lr(t),t.length-e}decode(t,e=0){const n=this.getSpan(t,e);if(0<=this.maxSpan&&this.maxSpan<n)throw new RangeError("text length exceeds maxSpan");return at(t).slice(e,e+n).toString("utf-8")}encode(t,e,n=0){typeof t!="string"&&(t=String(t));const i=Qn.Buffer.from(t,"utf8"),o=i.length;if(0<=this.maxSpan&&this.maxSpan<o)throw new RangeError("text length exceeds maxSpan");if(n+o>e.length)throw new RangeError("encoding overruns Buffer");return i.copy(at(e),n),o}}w.UTF8=ts;class es extends lt{constructor(t,e){super(0,e),this.value=t}decode(t,e){return this.value}encode(t,e,n){return 0}}w.Constant=es,w.greedy=(r,t)=>new qo(r,t);var Qe=w.offset=(r,t,e)=>new ei(r,t,e),nt=w.u8=r=>new Xt(1,r),Qt=w.u16=r=>new Xt(2,r);w.u24=r=>new Xt(3,r);var j=w.u32=r=>new Xt(4,r);w.u40=r=>new Xt(5,r),w.u48=r=>new Xt(6,r);var Ot=w.nu64=r=>new Fo(r);w.u16be=r=>new ae(2,r),w.u24be=r=>new ae(3,r),w.u32be=r=>new ae(4,r),w.u40be=r=>new ae(5,r),w.u48be=r=>new ae(6,r),w.nu64be=r=>new Ko(r),w.s8=r=>new Xe(1,r),w.s16=r=>new Xe(2,r),w.s24=r=>new Xe(3,r),w.s32=r=>new Xe(4,r),w.s40=r=>new Xe(5,r),w.s48=r=>new Xe(6,r);var Zt=w.ns64=r=>new Wo(r);w.s16be=r=>new hr(2,r),w.s24be=r=>new hr(3,r),w.s32be=r=>new hr(4,r),w.s40be=r=>new hr(5,r),w.s48be=r=>new hr(6,r),w.ns64be=r=>new $o(r),w.f32=r=>new Mo(r),w.f32be=r=>new jo(r),w.f64=r=>new Do(r),w.f64be=r=>new Vo(r);var W=w.struct=(r,t,e)=>new Zo(r,t,e);w.bits=(r,t,e)=>new oi(r,t,e);var $t=w.seq=(r,t,e)=>new Go(r,t,e);w.union=(r,t,e)=>new ii(r,t,e),w.unionLayoutDiscriminator=(r,t)=>new on(r,t);var gt=w.blob=(r,t)=>new Xo(r,t);w.cstr=r=>new Qo(r),w.utf8=(r,t)=>new ts(r,t),w.constant=(r,t)=>new es(r,t);var Tr={};Object.defineProperty(Tr,"__esModule",{value:!0});function Bu(r){{const t=yt.from(r);t.reverse();const e=t.toString("hex");return e.length===0?BigInt(0):BigInt(`0x${e}`)}}var rs=Tr.toBigIntLE=Bu;function Au(r){{const t=r.toString("hex");return t.length===0?BigInt(0):BigInt(`0x${t}`)}}Tr.toBigIntBE=Au;function Iu(r,t){{const e=r.toString(16),n=yt.from(e.padStart(t*2,"0").slice(0,t*2),"hex");return n.reverse(),n}}var ns=Tr.toBufferLE=Iu;function _u(r,t){{const e=r.toString(16);return yt.from(e.padStart(t*2,"0").slice(0,t*2),"hex")}}Tr.toBufferBE=_u;class Lu extends TypeError{constructor(t,e){let n;const{message:i,explanation:o,...s}=t,{path:a}=t,c=a.length===0?i:`At path: ${a.join(".")} -- ${i}`;super(o??c),o!=null&&(this.cause=c),Object.assign(this,s),this.name=this.constructor.name,this.failures=()=>n??(n=[t,...e()])}}function Cu(r){return Or(r)&&typeof r[Symbol.iterator]=="function"}function Or(r){return typeof r=="object"&&r!=null}function sn(r){return Or(r)&&!Array.isArray(r)}function ce(r){return typeof r=="symbol"?r.toString():typeof r=="string"?JSON.stringify(r):`${r}`}function Tu(r){const{done:t,value:e}=r.next();return t?void 0:e}function Ou(r,t,e,n){if(r===!0)return;r===!1?r={}:typeof r=="string"&&(r={message:r});const{path:i,branch:o}=t,{type:s}=e,{refinement:a,message:c=`Expected a value of type \`${s}\`${a?` with refinement \`${a}\``:""}, but received: \`${ce(n)}\``}=r;return{value:n,type:s,refinement:a,key:i[i.length-1],path:i,branch:o,...r,message:c}}function*is(r,t,e,n){Cu(r)||(r=[r]);for(const i of r){const o=Ou(i,t,e,n);o&&(yield o)}}function*ai(r,t,e={}){const{path:n=[],branch:i=[r],coerce:o=!1,mask:s=!1}=e,a={path:n,branch:i,mask:s};o&&(r=t.coercer(r,a));let c="valid";for(const u of t.validator(r,a))u.explanation=e.message,c="not_valid",yield[u,void 0];for(let[u,l,h]of t.entries(r,a)){const y=ai(l,h,{path:u===void 0?n:[...n,u],branch:u===void 0?i:[...i,l],coerce:o,mask:s,message:e.message});for(const f of y)f[0]?(c=f[0].refinement!=null?"not_refined":"not_valid",yield[f[0],void 0]):o&&(l=f[1],u===void 0?r=l:r instanceof Map?r.set(u,l):r instanceof Set?r.add(l):Or(r)&&(l!==void 0||u in r)&&(r[u]=l))}if(c!=="not_valid")for(const u of t.refiner(r,a))u.explanation=e.message,c="not_refined",yield[u,void 0];c==="valid"&&(yield[void 0,r])}let ge=class{constructor(r){const{type:t,schema:e,validator:n,refiner:i,coercer:o=a=>a,entries:s=function*(){}}=r;this.type=t,this.schema=e,this.entries=s,this.coercer=o,n?this.validator=(a,c)=>{const u=n(a,c);return is(u,c,this,a)}:this.validator=()=>[],i?this.refiner=(a,c)=>{const u=i(a,c);return is(u,c,this,a)}:this.refiner=()=>[]}assert(r,t){return Pu(r,this,t)}create(r,t){return O(r,this,t)}is(r){return os(r,this)}mask(r,t){return Ru(r,this,t)}validate(r,t={}){return Pr(r,this,t)}};function Pu(r,t,e){const n=Pr(r,t,{message:e});if(n[0])throw n[0]}function O(r,t,e){const n=Pr(r,t,{coerce:!0,message:e});if(n[0])throw n[0];return n[1]}function Ru(r,t,e){const n=Pr(r,t,{coerce:!0,mask:!0,message:e});if(n[0])throw n[0];return n[1]}function os(r,t){return!Pr(r,t)[0]}function Pr(r,t,e={}){const n=ai(r,t,e),i=Tu(n);return i[0]?[new Lu(i[0],function*(){for(const o of n)o[0]&&(yield o[0])}),void 0]:[void 0,i[1]]}function tr(r,t){return new ge({type:r,schema:null,validator:t})}function Uu(){return tr("any",()=>!0)}function U(r){return new ge({type:"array",schema:r,*entries(t){if(r&&Array.isArray(t))for(const[e,n]of t.entries())yield[e,n,r]},coercer(t){return Array.isArray(t)?t.slice():t},validator(t){return Array.isArray(t)||`Expected an array value, but received: ${ce(t)}`}})}function ye(){return tr("boolean",r=>typeof r=="boolean")}function ci(r){return tr("instance",t=>t instanceof r||`Expected a \`${r.name}\` instance, but received: ${ce(t)}`)}function bt(r){const t=ce(r),e=typeof r;return new ge({type:"literal",schema:e==="string"||e==="number"||e==="boolean"?r:null,validator(n){return n===r||`Expected the literal \`${t}\`, but received: ${ce(n)}`}})}function Nu(){return tr("never",()=>!1)}function H(r){return new ge({...r,validator:(t,e)=>t===null||r.validator(t,e),refiner:(t,e)=>t===null||r.refiner(t,e)})}function b(){return tr("number",r=>typeof r=="number"&&!isNaN(r)||`Expected a number, but received: ${ce(r)}`)}function G(r){return new ge({...r,validator:(t,e)=>t===void 0||r.validator(t,e),refiner:(t,e)=>t===void 0||r.refiner(t,e)})}function ss(r,t){return new ge({type:"record",schema:null,*entries(e){if(Or(e))for(const n in e){const i=e[n];yield[n,n,r],yield[n,i,t]}},validator(e){return sn(e)||`Expected an object, but received: ${ce(e)}`},coercer(e){return sn(e)?{...e}:e}})}function L(){return tr("string",r=>typeof r=="string"||`Expected a string, but received: ${ce(r)}`)}function ui(r){const t=Nu();return new ge({type:"tuple",schema:null,*entries(e){if(Array.isArray(e)){const n=Math.max(r.length,e.length);for(let i=0;i<n;i++)yield[i,e[i],r[i]||t]}},validator(e){return Array.isArray(e)||`Expected an array, but received: ${ce(e)}`},coercer(e){return Array.isArray(e)?e.slice():e}})}function A(r){const t=Object.keys(r);return new ge({type:"type",schema:r,*entries(e){if(Or(e))for(const n of t)yield[n,e[n],r[n]]},validator(e){return sn(e)||`Expected an object, but received: ${ce(e)}`},coercer(e){return sn(e)?{...e}:e}})}function Mt(r){const t=r.map(e=>e.type).join(" | ");return new ge({type:"union",schema:null,coercer(e,n){for(const i of r){const[o,s]=i.validate(e,{coerce:!0,mask:n.mask});if(!o)return s}return e},validator(e,n){const i=[];for(const o of r){const[...s]=ai(e,o,n),[a]=s;if(a[0])for(const[c]of s)c&&i.push(c);else return[]}return[`Expected the value to satisfy a union of \`${t}\`, but received: ${ce(e)}`,...i]}})}function fr(){return tr("unknown",()=>!0)}function Rr(r,t,e){return new ge({...r,coercer:(n,i)=>os(n,t)?r.coercer(e(n,i),i):r.coercer(n,i)})}var an,zu=new Uint8Array(16);function as(){if(!an&&(an=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||typeof msCrypto<"u"&&typeof msCrypto.getRandomValues=="function"&&msCrypto.getRandomValues.bind(msCrypto),!an))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return an(zu)}const Hu=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;function cn(r){return typeof r=="string"&&Hu.test(r)}for(var Pt=[],li=0;li<256;++li)Pt.push((li+256).toString(16).substr(1));function un(r){var t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0,e=(Pt[r[t+0]]+Pt[r[t+1]]+Pt[r[t+2]]+Pt[r[t+3]]+"-"+Pt[r[t+4]]+Pt[r[t+5]]+"-"+Pt[r[t+6]]+Pt[r[t+7]]+"-"+Pt[r[t+8]]+Pt[r[t+9]]+"-"+Pt[r[t+10]]+Pt[r[t+11]]+Pt[r[t+12]]+Pt[r[t+13]]+Pt[r[t+14]]+Pt[r[t+15]]).toLowerCase();if(!cn(e))throw TypeError("Stringified UUID is invalid");return e}var cs,hi,di=0,fi=0;function qu(r,t,e){var n=t&&e||0,i=t||new Array(16);r=r||{};var o=r.node||cs,s=r.clockseq!==void 0?r.clockseq:hi;if(o==null||s==null){var a=r.random||(r.rng||as)();o==null&&(o=cs=[a[0]|1,a[1],a[2],a[3],a[4],a[5]]),s==null&&(s=hi=(a[6]<<8|a[7])&16383)}var c=r.msecs!==void 0?r.msecs:Date.now(),u=r.nsecs!==void 0?r.nsecs:fi+1,l=c-di+(u-fi)/1e4;if(l<0&&r.clockseq===void 0&&(s=s+1&16383),(l<0||c>di)&&r.nsecs===void 0&&(u=0),u>=1e4)throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");di=c,fi=u,hi=s,c+=122192928e5;var h=((c&268435455)*1e4+u)%4294967296;i[n++]=h>>>24&255,i[n++]=h>>>16&255,i[n++]=h>>>8&255,i[n++]=h&255;var y=c/4294967296*1e4&268435455;i[n++]=y>>>8&255,i[n++]=y&255,i[n++]=y>>>24&15|16,i[n++]=y>>>16&255,i[n++]=s>>>8|128,i[n++]=s&255;for(var f=0;f<6;++f)i[n+f]=o[f];return t||un(i)}function us(r){if(!cn(r))throw TypeError("Invalid UUID");var t,e=new Uint8Array(16);return e[0]=(t=parseInt(r.slice(0,8),16))>>>24,e[1]=t>>>16&255,e[2]=t>>>8&255,e[3]=t&255,e[4]=(t=parseInt(r.slice(9,13),16))>>>8,e[5]=t&255,e[6]=(t=parseInt(r.slice(14,18),16))>>>8,e[7]=t&255,e[8]=(t=parseInt(r.slice(19,23),16))>>>8,e[9]=t&255,e[10]=(t=parseInt(r.slice(24,36),16))/1099511627776&255,e[11]=t/4294967296&255,e[12]=t>>>24&255,e[13]=t>>>16&255,e[14]=t>>>8&255,e[15]=t&255,e}function Fu(r){r=unescape(encodeURIComponent(r));for(var t=[],e=0;e<r.length;++e)t.push(r.charCodeAt(e));return t}var Ku="6ba7b810-9dad-11d1-80b4-00c04fd430c8",Wu="6ba7b811-9dad-11d1-80b4-00c04fd430c8";function ls(r,t,e){function n(i,o,s,a){if(typeof i=="string"&&(i=Fu(i)),typeof o=="string"&&(o=us(o)),o.length!==16)throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");var c=new Uint8Array(16+i.length);if(c.set(o),c.set(i,o.length),c=e(c),c[6]=c[6]&15|t,c[8]=c[8]&63|128,s){a=a||0;for(var u=0;u<16;++u)s[a+u]=c[u];return s}return un(c)}try{n.name=r}catch{}return n.DNS=Ku,n.URL=Wu,n}function $u(r){if(typeof r=="string"){var t=unescape(encodeURIComponent(r));r=new Uint8Array(t.length);for(var e=0;e<t.length;++e)r[e]=t.charCodeAt(e)}return Mu(ju(Du(r),r.length*8))}function Mu(r){for(var t=[],e=r.length*32,n="0123456789abcdef",i=0;i<e;i+=8){var o=r[i>>5]>>>i%32&255,s=parseInt(n.charAt(o>>>4&15)+n.charAt(o&15),16);t.push(s)}return t}function hs(r){return(r+64>>>9<<4)+14+1}function ju(r,t){r[t>>5]|=128<<t%32,r[hs(t)-1]=t;for(var e=1732584193,n=-271733879,i=-1732584194,o=271733878,s=0;s<r.length;s+=16){var a=e,c=n,u=i,l=o;e=Ht(e,n,i,o,r[s],7,-680876936),o=Ht(o,e,n,i,r[s+1],12,-389564586),i=Ht(i,o,e,n,r[s+2],17,606105819),n=Ht(n,i,o,e,r[s+3],22,-1044525330),e=Ht(e,n,i,o,r[s+4],7,-176418897),o=Ht(o,e,n,i,r[s+5],12,1200080426),i=Ht(i,o,e,n,r[s+6],17,-1473231341),n=Ht(n,i,o,e,r[s+7],22,-45705983),e=Ht(e,n,i,o,r[s+8],7,1770035416),o=Ht(o,e,n,i,r[s+9],12,-1958414417),i=Ht(i,o,e,n,r[s+10],17,-42063),n=Ht(n,i,o,e,r[s+11],22,-1990404162),e=Ht(e,n,i,o,r[s+12],7,1804603682),o=Ht(o,e,n,i,r[s+13],12,-40341101),i=Ht(i,o,e,n,r[s+14],17,-1502002290),n=Ht(n,i,o,e,r[s+15],22,1236535329),e=qt(e,n,i,o,r[s+1],5,-165796510),o=qt(o,e,n,i,r[s+6],9,-1069501632),i=qt(i,o,e,n,r[s+11],14,643717713),n=qt(n,i,o,e,r[s],20,-373897302),e=qt(e,n,i,o,r[s+5],5,-701558691),o=qt(o,e,n,i,r[s+10],9,38016083),i=qt(i,o,e,n,r[s+15],14,-660478335),n=qt(n,i,o,e,r[s+4],20,-405537848),e=qt(e,n,i,o,r[s+9],5,568446438),o=qt(o,e,n,i,r[s+14],9,-1019803690),i=qt(i,o,e,n,r[s+3],14,-187363961),n=qt(n,i,o,e,r[s+8],20,1163531501),e=qt(e,n,i,o,r[s+13],5,-1444681467),o=qt(o,e,n,i,r[s+2],9,-51403784),i=qt(i,o,e,n,r[s+7],14,1735328473),n=qt(n,i,o,e,r[s+12],20,-1926607734),e=Ft(e,n,i,o,r[s+5],4,-378558),o=Ft(o,e,n,i,r[s+8],11,-2022574463),i=Ft(i,o,e,n,r[s+11],16,1839030562),n=Ft(n,i,o,e,r[s+14],23,-35309556),e=Ft(e,n,i,o,r[s+1],4,-1530992060),o=Ft(o,e,n,i,r[s+4],11,1272893353),i=Ft(i,o,e,n,r[s+7],16,-155497632),n=Ft(n,i,o,e,r[s+10],23,-1094730640),e=Ft(e,n,i,o,r[s+13],4,681279174),o=Ft(o,e,n,i,r[s],11,-358537222),i=Ft(i,o,e,n,r[s+3],16,-722521979),n=Ft(n,i,o,e,r[s+6],23,76029189),e=Ft(e,n,i,o,r[s+9],4,-640364487),o=Ft(o,e,n,i,r[s+12],11,-421815835),i=Ft(i,o,e,n,r[s+15],16,530742520),n=Ft(n,i,o,e,r[s+2],23,-995338651),e=Kt(e,n,i,o,r[s],6,-198630844),o=Kt(o,e,n,i,r[s+7],10,1126891415),i=Kt(i,o,e,n,r[s+14],15,-1416354905),n=Kt(n,i,o,e,r[s+5],21,-57434055),e=Kt(e,n,i,o,r[s+12],6,1700485571),o=Kt(o,e,n,i,r[s+3],10,-1894986606),i=Kt(i,o,e,n,r[s+10],15,-1051523),n=Kt(n,i,o,e,r[s+1],21,-2054922799),e=Kt(e,n,i,o,r[s+8],6,1873313359),o=Kt(o,e,n,i,r[s+15],10,-30611744),i=Kt(i,o,e,n,r[s+6],15,-1560198380),n=Kt(n,i,o,e,r[s+13],21,1309151649),e=Kt(e,n,i,o,r[s+4],6,-145523070),o=Kt(o,e,n,i,r[s+11],10,-1120210379),i=Kt(i,o,e,n,r[s+2],15,718787259),n=Kt(n,i,o,e,r[s+9],21,-343485551),e=Pe(e,a),n=Pe(n,c),i=Pe(i,u),o=Pe(o,l)}return[e,n,i,o]}function Du(r){if(r.length===0)return[];for(var t=r.length*8,e=new Uint32Array(hs(t)),n=0;n<t;n+=8)e[n>>5]|=(r[n/8]&255)<<n%32;return e}function Pe(r,t){var e=(r&65535)+(t&65535),n=(r>>16)+(t>>16)+(e>>16);return n<<16|e&65535}function Vu(r,t){return r<<t|r>>>32-t}function ln(r,t,e,n,i,o){return Pe(Vu(Pe(Pe(t,r),Pe(n,o)),i),e)}function Ht(r,t,e,n,i,o,s){return ln(t&e|~t&n,r,t,i,o,s)}function qt(r,t,e,n,i,o,s){return ln(t&n|e&~n,r,t,i,o,s)}function Ft(r,t,e,n,i,o,s){return ln(t^e^n,r,t,i,o,s)}function Kt(r,t,e,n,i,o,s){return ln(e^(t|~n),r,t,i,o,s)}var Gu=ls("v3",48,$u);const Zu=Gu;function Ju(r,t,e){r=r||{};var n=r.random||(r.rng||as)();if(n[6]=n[6]&15|64,n[8]=n[8]&63|128,t){e=e||0;for(var i=0;i<16;++i)t[e+i]=n[i];return t}return un(n)}function Yu(r,t,e,n){switch(r){case 0:return t&e^~t&n;case 1:return t^e^n;case 2:return t&e^t&n^e&n;case 3:return t^e^n}}function pi(r,t){return r<<t|r>>>32-t}function Xu(r){var t=[1518500249,1859775393,2400959708,3395469782],e=[1732584193,4023233417,2562383102,271733878,3285377520];if(typeof r=="string"){var n=unescape(encodeURIComponent(r));r=[];for(var i=0;i<n.length;++i)r.push(n.charCodeAt(i))}else Array.isArray(r)||(r=Array.prototype.slice.call(r));r.push(128);for(var o=r.length/4+2,s=Math.ceil(o/16),a=new Array(s),c=0;c<s;++c){for(var u=new Uint32Array(16),l=0;l<16;++l)u[l]=r[c*64+l*4]<<24|r[c*64+l*4+1]<<16|r[c*64+l*4+2]<<8|r[c*64+l*4+3];a[c]=u}a[s-1][14]=(r.length-1)*8/Math.pow(2,32),a[s-1][14]=Math.floor(a[s-1][14]),a[s-1][15]=(r.length-1)*8&4294967295;for(var h=0;h<s;++h){for(var y=new Uint32Array(80),f=0;f<16;++f)y[f]=a[h][f];for(var p=16;p<80;++p)y[p]=pi(y[p-3]^y[p-8]^y[p-14]^y[p-16],1);for(var d=e[0],g=e[1],S=e[2],B=e[3],x=e[4],C=0;C<80;++C){var E=Math.floor(C/20),I=pi(d,5)+Yu(E,g,S,B)+x+t[E]+y[C]>>>0;x=B,B=S,S=pi(g,30)>>>0,g=d,d=I}e[0]=e[0]+d>>>0,e[1]=e[1]+g>>>0,e[2]=e[2]+S>>>0,e[3]=e[3]+B>>>0,e[4]=e[4]+x>>>0}return[e[0]>>24&255,e[0]>>16&255,e[0]>>8&255,e[0]&255,e[1]>>24&255,e[1]>>16&255,e[1]>>8&255,e[1]&255,e[2]>>24&255,e[2]>>16&255,e[2]>>8&255,e[2]&255,e[3]>>24&255,e[3]>>16&255,e[3]>>8&255,e[3]&255,e[4]>>24&255,e[4]>>16&255,e[4]>>8&255,e[4]&255]}var Qu=ls("v5",80,Xu);const tl=Qu,el="00000000-0000-0000-0000-000000000000";function rl(r){if(!cn(r))throw TypeError("Invalid UUID");return parseInt(r.substr(14,1),16)}const nl=Object.freeze(Object.defineProperty({__proto__:null,NIL:el,parse:us,stringify:un,v1:qu,v3:Zu,v4:Ju,v5:tl,validate:cn,version:rl},Symbol.toStringTag,{value:"Module"})),ds=io(nl),il=ds.v4,ol=function(r,t,e,n){if(typeof r!="string")throw new TypeError(r+" must be a string");n=n||{};const i=typeof n.version=="number"?n.version:2;if(i!==1&&i!==2)throw new TypeError(i+" must be 1 or 2");const o={method:r};if(i===2&&(o.jsonrpc="2.0"),t){if(typeof t!="object"&&!Array.isArray(t))throw new TypeError(t+" must be an object, array or omitted");o.params=t}if(typeof e>"u"){const s=typeof n.generator=="function"?n.generator:function(){return il()};o.id=s(o,n)}else i===2&&e===null?n.notificationIdNull&&(o.id=null):o.id=e;return o};var sl=ol;const al=ds.v4,cl=sl,Ur=function(r,t){if(!(this instanceof Ur))return new Ur(r,t);t||(t={}),this.options={reviver:typeof t.reviver<"u"?t.reviver:null,replacer:typeof t.replacer<"u"?t.replacer:null,generator:typeof t.generator<"u"?t.generator:function(){return al()},version:typeof t.version<"u"?t.version:2,notificationIdNull:typeof t.notificationIdNull=="boolean"?t.notificationIdNull:!1},this.callServer=r};var ul=Ur;Ur.prototype.request=function(r,t,e,n){const i=this;let o=null;const s=Array.isArray(r)&&typeof t=="function";if(this.options.version===1&&s)throw new TypeError("JSON-RPC 1.0 does not support batching");if(s||!s&&r&&typeof r=="object"&&typeof t=="function")n=t,o=r;else{typeof e=="function"&&(n=e,e=void 0);const c=typeof n=="function";try{o=cl(r,t,e,{generator:this.options.generator,version:this.options.version,notificationIdNull:this.options.notificationIdNull})}catch(u){if(c)return n(u);throw u}if(!c)return o}let a;try{a=JSON.stringify(o,this.options.replacer)}catch(c){return n(c)}return this.callServer(a,function(c,u){i._parseResponse(c,u,n)}),o},Ur.prototype._parseResponse=function(r,t,e){if(r){e(r);return}if(!t)return e();let n;try{n=JSON.parse(t,this.options.reviver)}catch(i){return e(i)}if(e.length===3)if(Array.isArray(n)){const i=function(s){return typeof s.error<"u"},o=function(s){return!i(s)};return e(null,n.filter(i),n.filter(o))}else return e(null,n.error,n.result);e(null,n)};const ll=no(ul);var hl=class extends oo{constructor(t,e,n){super();It(this,"socket");this.socket=new window.WebSocket(t,n),this.socket.onopen=()=>this.emit("open"),this.socket.onmessage=i=>this.emit("message",i.data),this.socket.onerror=i=>this.emit("error",i),this.socket.onclose=i=>{this.emit("close",i.code,i.reason)}}send(t,e,n){const i=n||e;try{this.socket.send(t),i()}catch(o){i(o)}}close(t,e){this.socket.close(t,e)}addEventListener(t,e,n){this.socket.addEventListener(t,e,n)}};function dl(r,t){return new hl(r,t)}var fl=class{encode(r){return JSON.stringify(r)}decode(r){return JSON.parse(r)}},pl=class extends oo{constructor(t,e="ws://localhost:8080",{autoconnect:n=!0,reconnect:i=!0,reconnect_interval:o=1e3,max_reconnects:s=5,...a}={},c,u){super();It(this,"address");It(this,"rpc_id");It(this,"queue");It(this,"options");It(this,"autoconnect");It(this,"ready");It(this,"reconnect");It(this,"reconnect_timer_id");It(this,"reconnect_interval");It(this,"max_reconnects");It(this,"rest_options");It(this,"current_reconnects");It(this,"generate_request_id");It(this,"socket");It(this,"webSocketFactory");It(this,"dataPack");this.webSocketFactory=t,this.queue={},this.rpc_id=0,this.address=e,this.autoconnect=n,this.ready=!1,this.reconnect=i,this.reconnect_timer_id=void 0,this.reconnect_interval=o,this.max_reconnects=s,this.rest_options=a,this.current_reconnects=0,this.generate_request_id=c||(()=>++this.rpc_id),u?this.dataPack=u:this.dataPack=new fl,this.autoconnect&&this._connect(this.address,{autoconnect:this.autoconnect,reconnect:this.reconnect,reconnect_interval:this.reconnect_interval,max_reconnects:this.max_reconnects,...this.rest_options})}connect(){this.socket||this._connect(this.address,{autoconnect:this.autoconnect,reconnect:this.reconnect,reconnect_interval:this.reconnect_interval,max_reconnects:this.max_reconnects,...this.rest_options})}call(t,e,n,i){return!i&&typeof n=="object"&&(i=n,n=null),new Promise((o,s)=>{if(!this.ready)return s(new Error("socket not ready"));const a=this.generate_request_id(t,e),c={jsonrpc:"2.0",method:t,params:e||void 0,id:a};this.socket.send(this.dataPack.encode(c),i,u=>{if(u)return s(u);this.queue[a]={promise:[o,s]},n&&(this.queue[a].timeout=setTimeout(()=>{delete this.queue[a],s(new Error("reply timeout"))},n))})})}async login(t){const e=await this.call("rpc.login",t);if(!e)throw new Error("authentication failed");return e}async listMethods(){return await this.call("__listMethods")}notify(t,e){return new Promise((n,i)=>{if(!this.ready)return i(new Error("socket not ready"));const o={jsonrpc:"2.0",method:t,params:e};this.socket.send(this.dataPack.encode(o),s=>{if(s)return i(s);n()})})}async subscribe(t){typeof t=="string"&&(t=[t]);const e=await this.call("rpc.on",t);if(typeof t=="string"&&e[t]!=="ok")throw new Error("Failed subscribing to an event '"+t+"' with: "+e[t]);return e}async unsubscribe(t){typeof t=="string"&&(t=[t]);const e=await this.call("rpc.off",t);if(typeof t=="string"&&e[t]!=="ok")throw new Error("Failed unsubscribing from an event with: "+e);return e}close(t,e){this.socket.close(t||1e3,e)}setAutoReconnect(t){this.reconnect=t}setReconnectInterval(t){this.reconnect_interval=t}setMaxReconnects(t){this.max_reconnects=t}_connect(t,e){clearTimeout(this.reconnect_timer_id),this.socket=this.webSocketFactory(t,e),this.socket.addEventListener("open",()=>{this.ready=!0,this.emit("open"),this.current_reconnects=0}),this.socket.addEventListener("message",({data:n})=>{n instanceof ArrayBuffer&&(n=Y.from(n).toString());try{n=this.dataPack.decode(n)}catch{return}if(n.notification&&this.listeners(n.notification).length){if(!Object.keys(n.params).length)return this.emit(n.notification);const i=[n.notification];if(n.params.constructor===Object)i.push(n.params);else for(let o=0;o<n.params.length;o++)i.push(n.params[o]);return Promise.resolve().then(()=>{this.emit.apply(this,i)})}if(!this.queue[n.id])return n.method?Promise.resolve().then(()=>{this.emit(n.method,n==null?void 0:n.params)}):void 0;"error"in n=="result"in n&&this.queue[n.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.')),this.queue[n.id].timeout&&clearTimeout(this.queue[n.id].timeout),n.error?this.queue[n.id].promise[1](n.error):this.queue[n.id].promise[0](n.result),delete this.queue[n.id]}),this.socket.addEventListener("error",n=>this.emit("error",n)),this.socket.addEventListener("close",({code:n,reason:i})=>{this.ready&&setTimeout(()=>this.emit("close",n,i),0),this.ready=!1,this.socket=void 0,n!==1e3&&(this.current_reconnects++,this.reconnect&&(this.max_reconnects>this.current_reconnects||this.max_reconnects===0)&&(this.reconnect_timer_id=setTimeout(()=>this._connect(t,e),this.reconnect_interval)))})}};class fs extends ho{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,Ha(t);const n=Hn(e);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const i=this.blockLen,o=new Uint8Array(i);o.set(n.length>i?t.create().update(n).digest():n);for(let s=0;s<o.length;s++)o[s]^=54;this.iHash.update(o),this.oHash=t.create();for(let s=0;s<o.length;s++)o[s]^=106;this.oHash.update(o),o.fill(0)}update(t){return jr(this),this.iHash.update(t),this}digestInto(t){jr(this),Mr(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:n,finished:i,destroyed:o,blockLen:s,outputLen:a}=this;return t=t,t.finished=i,t.destroyed=o,t.blockLen=s,t.outputLen=a,t.oHash=e._cloneInto(t.oHash),t.iHash=n._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const ps=(r,t,e)=>new fs(r,t).update(e).digest();ps.create=(r,t)=>new fs(r,t);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function gl(r){const t=Dn(r);cr(t,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:e,Fp:n,a:i}=t;if(e){if(!n.eql(i,n.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof e!="object"||typeof e.beta!="bigint"||typeof e.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...t})}const{bytesToNumberBE:yl,hexToBytes:ml}=Bc,er={Err:class extends Error{constructor(r=""){super(r)}},_parseInt(r){const{Err:t}=er;if(r.length<2||r[0]!==2)throw new t("Invalid signature integer tag");const e=r[1],n=r.subarray(2,e+2);if(!e||n.length!==e)throw new t("Invalid signature integer: wrong length");if(n[0]&128)throw new t("Invalid signature integer: negative");if(n[0]===0&&!(n[1]&128))throw new t("Invalid signature integer: unnecessary leading zero");return{d:yl(n),l:r.subarray(e+2)}},toSig(r){const{Err:t}=er,e=typeof r=="string"?ml(r):r;_r(e);let n=e.length;if(n<2||e[0]!=48)throw new t("Invalid signature tag");if(e[1]!==n-2)throw new t("Invalid signature: incorrect length");const{d:i,l:o}=er._parseInt(e.subarray(2)),{d:s,l:a}=er._parseInt(o);if(a.length)throw new t("Invalid signature: left bytes after parsing");return{r:i,s}},hexFromSig(r){const t=u=>Number.parseInt(u[0],16)&8?"00"+u:u,e=u=>{const l=u.toString(16);return l.length&1?`0${l}`:l},n=t(e(r.s)),i=t(e(r.r)),o=n.length/2,s=i.length/2,a=e(o),c=e(s);return`30${e(s+o+4)}02${c}${i}02${a}${n}`}},Se=BigInt(0),te=BigInt(1);BigInt(2);const gs=BigInt(3);BigInt(4);function bl(r){const t=gl(r),{Fp:e}=t,n=t.toBytes||((p,d,g)=>{const S=d.toAffine();return Ge(Uint8Array.from([4]),e.toBytes(S.x),e.toBytes(S.y))}),i=t.fromBytes||(p=>{const d=p.subarray(1),g=e.fromBytes(d.subarray(0,e.BYTES)),S=e.fromBytes(d.subarray(e.BYTES,2*e.BYTES));return{x:g,y:S}});function o(p){const{a:d,b:g}=t,S=e.sqr(p),B=e.mul(S,p);return e.add(e.add(B,e.mul(p,d)),g)}if(!e.eql(e.sqr(t.Gy),o(t.Gx)))throw new Error("bad generator point: equation left != right");function s(p){return typeof p=="bigint"&&Se<p&&p<t.n}function a(p){if(!s(p))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function c(p){const{allowedPrivateKeyLengths:d,nByteLength:g,wrapPrivateKey:S,n:B}=t;if(d&&typeof p!="bigint"){if(je(p)&&(p=De(p)),typeof p!="string"||!d.includes(p.length))throw new Error("Invalid key");p=p.padStart(g*2,"0")}let x;try{x=typeof p=="bigint"?p:Ve(Bt("private key",p,g))}catch{throw new Error(`private key must be ${g} bytes, hex or bigint, not ${typeof p}`)}return S&&(x=pt(x,B)),a(x),x}const u=new Map;function l(p){if(!(p instanceof h))throw new Error("ProjectivePoint expected")}class h{constructor(d,g,S){if(this.px=d,this.py=g,this.pz=S,d==null||!e.isValid(d))throw new Error("x required");if(g==null||!e.isValid(g))throw new Error("y required");if(S==null||!e.isValid(S))throw new Error("z required")}static fromAffine(d){const{x:g,y:S}=d||{};if(!d||!e.isValid(g)||!e.isValid(S))throw new Error("invalid affine point");if(d instanceof h)throw new Error("projective point not allowed");const B=x=>e.eql(x,e.ZERO);return B(g)&&B(S)?h.ZERO:new h(g,S,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(d){const g=e.invertBatch(d.map(S=>S.pz));return d.map((S,B)=>S.toAffine(g[B])).map(h.fromAffine)}static fromHex(d){const g=h.fromAffine(i(Bt("pointHex",d)));return g.assertValidity(),g}static fromPrivateKey(d){return h.BASE.multiply(c(d))}_setWindowSize(d){this._WINDOW_SIZE=d,u.delete(this)}assertValidity(){if(this.is0()){if(t.allowInfinityPoint&&!e.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:d,y:g}=this.toAffine();if(!e.isValid(d)||!e.isValid(g))throw new Error("bad point: x or y not FE");const S=e.sqr(g),B=o(d);if(!e.eql(S,B))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:d}=this.toAffine();if(e.isOdd)return!e.isOdd(d);throw new Error("Field doesn't support isOdd")}equals(d){l(d);const{px:g,py:S,pz:B}=this,{px:x,py:C,pz:E}=d,I=e.eql(e.mul(g,E),e.mul(x,B)),P=e.eql(e.mul(S,E),e.mul(C,B));return I&&P}negate(){return new h(this.px,e.neg(this.py),this.pz)}double(){const{a:d,b:g}=t,S=e.mul(g,gs),{px:B,py:x,pz:C}=this;let E=e.ZERO,I=e.ZERO,P=e.ZERO,N=e.mul(B,B),rt=e.mul(x,x),X=e.mul(C,C),Z=e.mul(B,x);return Z=e.add(Z,Z),P=e.mul(B,C),P=e.add(P,P),E=e.mul(d,P),I=e.mul(S,X),I=e.add(E,I),E=e.sub(rt,I),I=e.add(rt,I),I=e.mul(E,I),E=e.mul(Z,E),P=e.mul(S,P),X=e.mul(d,X),Z=e.sub(N,X),Z=e.mul(d,Z),Z=e.add(Z,P),P=e.add(N,N),N=e.add(P,N),N=e.add(N,X),N=e.mul(N,Z),I=e.add(I,N),X=e.mul(x,C),X=e.add(X,X),N=e.mul(X,Z),E=e.sub(E,N),P=e.mul(X,rt),P=e.add(P,P),P=e.add(P,P),new h(E,I,P)}add(d){l(d);const{px:g,py:S,pz:B}=this,{px:x,py:C,pz:E}=d;let I=e.ZERO,P=e.ZERO,N=e.ZERO;const rt=t.a,X=e.mul(t.b,gs);let Z=e.mul(g,x),ht=e.mul(S,C),ut=e.mul(B,E),Nt=e.add(g,S),T=e.add(x,C);Nt=e.mul(Nt,T),T=e.add(Z,ht),Nt=e.sub(Nt,T),T=e.add(g,B);let $=e.add(x,E);return T=e.mul(T,$),$=e.add(Z,ut),T=e.sub(T,$),$=e.add(S,B),I=e.add(C,E),$=e.mul($,I),I=e.add(ht,ut),$=e.sub($,I),N=e.mul(rt,T),I=e.mul(X,ut),N=e.add(I,N),I=e.sub(ht,N),N=e.add(ht,N),P=e.mul(I,N),ht=e.add(Z,Z),ht=e.add(ht,Z),ut=e.mul(rt,ut),T=e.mul(X,T),ht=e.add(ht,ut),ut=e.sub(Z,ut),ut=e.mul(rt,ut),T=e.add(T,ut),Z=e.mul(ht,T),P=e.add(P,Z),Z=e.mul($,T),I=e.mul(Nt,I),I=e.sub(I,Z),Z=e.mul(Nt,ht),N=e.mul($,N),N=e.add(N,Z),new h(I,P,N)}subtract(d){return this.add(d.negate())}is0(){return this.equals(h.ZERO)}wNAF(d){return f.wNAFCached(this,u,d,g=>{const S=e.invertBatch(g.map(B=>B.pz));return g.map((B,x)=>B.toAffine(S[x])).map(h.fromAffine)})}multiplyUnsafe(d){const g=h.ZERO;if(d===Se)return g;if(a(d),d===te)return this;const{endo:S}=t;if(!S)return f.unsafeLadder(this,d);let{k1neg:B,k1:x,k2neg:C,k2:E}=S.splitScalar(d),I=g,P=g,N=this;for(;x>Se||E>Se;)x&te&&(I=I.add(N)),E&te&&(P=P.add(N)),N=N.double(),x>>=te,E>>=te;return B&&(I=I.negate()),C&&(P=P.negate()),P=new h(e.mul(P.px,S.beta),P.py,P.pz),I.add(P)}multiply(d){a(d);let g=d,S,B;const{endo:x}=t;if(x){const{k1neg:C,k1:E,k2neg:I,k2:P}=x.splitScalar(g);let{p:N,f:rt}=this.wNAF(E),{p:X,f:Z}=this.wNAF(P);N=f.constTimeNegate(C,N),X=f.constTimeNegate(I,X),X=new h(e.mul(X.px,x.beta),X.py,X.pz),S=N.add(X),B=rt.add(Z)}else{const{p:C,f:E}=this.wNAF(g);S=C,B=E}return h.normalizeZ([S,B])[0]}multiplyAndAddUnsafe(d,g,S){const B=h.BASE,x=(E,I)=>I===Se||I===te||!E.equals(B)?E.multiplyUnsafe(I):E.multiply(I),C=x(this,g).add(x(d,S));return C.is0()?void 0:C}toAffine(d){const{px:g,py:S,pz:B}=this,x=this.is0();d==null&&(d=x?e.ONE:e.inv(B));const C=e.mul(g,d),E=e.mul(S,d),I=e.mul(B,d);if(x)return{x:e.ZERO,y:e.ZERO};if(!e.eql(I,e.ONE))throw new Error("invZ was invalid");return{x:C,y:E}}isTorsionFree(){const{h:d,isTorsionFree:g}=t;if(d===te)return!0;if(g)return g(h,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:d,clearCofactor:g}=t;return d===te?this:g?g(h,this):this.multiplyUnsafe(t.h)}toRawBytes(d=!0){return this.assertValidity(),n(h,this,d)}toHex(d=!0){return De(this.toRawBytes(d))}}h.BASE=new h(t.Gx,t.Gy,e.ONE),h.ZERO=new h(e.ZERO,e.ONE,e.ZERO);const y=t.nBitLength,f=_o(h,t.endo?Math.ceil(y/2):y);return{CURVE:t,ProjectivePoint:h,normPrivateKeyToScalar:c,weierstrassEquation:o,isWithinCurveOrder:s}}function wl(r){const t=Dn(r);return cr(t,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...t})}function vl(r){const t=wl(r),{Fp:e,n}=t,i=e.BYTES+1,o=2*e.BYTES+1;function s(T){return Se<T&&T<e.ORDER}function a(T){return pt(T,n)}function c(T){return Mn(T,n)}const{ProjectivePoint:u,normPrivateKeyToScalar:l,weierstrassEquation:h,isWithinCurveOrder:y}=bl({...t,toBytes(T,$,v){const m=$.toAffine(),k=e.toBytes(m.x),_=Ge;return v?_(Uint8Array.from([$.hasEvenY()?2:3]),k):_(Uint8Array.from([4]),k,e.toBytes(m.y))},fromBytes(T){const $=T.length,v=T[0],m=T.subarray(1);if($===i&&(v===2||v===3)){const k=Ve(m);if(!s(k))throw new Error("Point is not on curve");const _=h(k);let R;try{R=e.sqrt(_)}catch(F){const D=F instanceof Error?": "+F.message:"";throw new Error("Point is not on curve"+D)}const z=(R&te)===te;return(v&1)===1!==z&&(R=e.neg(R)),{x:k,y:R}}else if($===o&&v===4){const k=e.fromBytes(m.subarray(0,e.BYTES)),_=e.fromBytes(m.subarray(e.BYTES,2*e.BYTES));return{x:k,y:_}}else throw new Error(`Point of length ${$} was invalid. Expected ${i} compressed bytes or ${o} uncompressed bytes`)}}),f=T=>De(ar(T,t.nByteLength));function p(T){const $=n>>te;return T>$}function d(T){return p(T)?a(-T):T}const g=(T,$,v)=>Ve(T.slice($,v));class S{constructor($,v,m){this.r=$,this.s=v,this.recovery=m,this.assertValidity()}static fromCompact($){const v=t.nByteLength;return $=Bt("compactSignature",$,v*2),new S(g($,0,v),g($,v,2*v))}static fromDER($){const{r:v,s:m}=er.toSig(Bt("DER",$));return new S(v,m)}assertValidity(){if(!y(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!y(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit($){return new S(this.r,this.s,$)}recoverPublicKey($){const{r:v,s:m,recovery:k}=this,_=P(Bt("msgHash",$));if(k==null||![0,1,2,3].includes(k))throw new Error("recovery id invalid");const R=k===2||k===3?v+t.n:v;if(R>=e.ORDER)throw new Error("recovery id 2 or 3 invalid");const z=k&1?"03":"02",F=u.fromHex(z+f(R)),D=c(R),K=a(-_*D),V=a(m*D),J=u.BASE.multiplyAndAddUnsafe(F,K,V);if(!J)throw new Error("point at infinify");return J.assertValidity(),J}hasHighS(){return p(this.s)}normalizeS(){return this.hasHighS()?new S(this.r,a(-this.s),this.recovery):this}toDERRawBytes(){return or(this.toDERHex())}toDERHex(){return er.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return or(this.toCompactHex())}toCompactHex(){return f(this.r)+f(this.s)}}const B={isValidPrivateKey(T){try{return l(T),!0}catch{return!1}},normPrivateKeyToScalar:l,randomPrivateKey:()=>{const T=Io(t.n);return Uc(t.randomBytes(T),t.n)},precompute(T=8,$=u.BASE){return $._setWindowSize(T),$.multiply(BigInt(3)),$}};function x(T,$=!0){return u.fromPrivateKey(T).toRawBytes($)}function C(T){const $=je(T),v=typeof T=="string",m=($||v)&&T.length;return $?m===i||m===o:v?m===2*i||m===2*o:T instanceof u}function E(T,$,v=!0){if(C(T))throw new Error("first arg must be private key");if(!C($))throw new Error("second arg must be public key");return u.fromHex($).multiply(l(T)).toRawBytes(v)}const I=t.bits2int||function(T){const $=Ve(T),v=T.length*8-t.nBitLength;return v>0?$>>BigInt(v):$},P=t.bits2int_modN||function(T){return a(I(T))},N=Kn(t.nBitLength);function rt(T){if(typeof T!="bigint")throw new Error("bigint expected");if(!(Se<=T&&T<N))throw new Error(`bigint expected < 2^${t.nBitLength}`);return ar(T,t.nByteLength)}function X(T,$,v=Z){if(["recovered","canonical"].some(dt=>dt in v))throw new Error("sign() legacy options not supported");const{hash:m,randomBytes:k}=t;let{lowS:_,prehash:R,extraEntropy:z}=v;_==null&&(_=!0),T=Bt("msgHash",T),R&&(T=Bt("prehashed msgHash",m(T)));const F=P(T),D=l($),K=[rt(D),rt(F)];if(z!=null&&z!==!1){const dt=z===!0?k(e.BYTES):z;K.push(Bt("extraEntropy",dt))}const V=Ge(...K),J=F;function st(dt){const ot=I(dt);if(!y(ot))return;const vt=c(ot),ct=u.BASE.multiply(ot).toAffine(),zt=a(ct.x);if(zt===Se)return;const jt=a(vt*a(J+zt*D));if(jt===Se)return;let Ae=(ct.x===zt?0:2)|Number(ct.y&te),Ie=jt;return _&&p(jt)&&(Ie=d(jt),Ae^=1),new S(zt,Ie,Ae)}return{seed:V,k2sig:st}}const Z={lowS:t.lowS,prehash:!1},ht={lowS:t.lowS,prehash:!1};function ut(T,$,v=Z){const{seed:m,k2sig:k}=X(T,$,v),_=t;return So(_.hash.outputLen,_.nByteLength,_.hmac)(m,k)}u.BASE._setWindowSize(8);function Nt(T,$,v,m=ht){var vt;const k=T;if($=Bt("msgHash",$),v=Bt("publicKey",v),"strict"in m)throw new Error("options.strict was renamed to lowS");const{lowS:_,prehash:R}=m;let z,F;try{if(typeof k=="string"||je(k))try{z=S.fromDER(k)}catch(ct){if(!(ct instanceof er.Err))throw ct;z=S.fromCompact(k)}else if(typeof k=="object"&&typeof k.r=="bigint"&&typeof k.s=="bigint"){const{r:ct,s:zt}=k;z=new S(ct,zt)}else throw new Error("PARSE");F=u.fromHex(v)}catch(ct){if(ct.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(_&&z.hasHighS())return!1;R&&($=t.hash($));const{r:D,s:K}=z,V=P($),J=c(K),st=a(V*J),dt=a(D*J),ot=(vt=u.BASE.multiplyAndAddUnsafe(F,st,dt))==null?void 0:vt.toAffine();return ot?a(ot.x)===D:!1}return{CURVE:t,getPublicKey:x,getSharedSecret:E,sign:ut,verify:Nt,ProjectivePoint:u,Signature:S,utils:B}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Sl(r){return{hash:r,hmac:(t,...e)=>ps(r,t,Ka(...e)),randomBytes:po}}function xl(r,t){const e=n=>vl({...r,...Sl(n)});return Object.freeze({...e(t),create:e})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ys=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),ms=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),El=BigInt(1),gi=BigInt(2),bs=(r,t)=>(r+t/gi)/t;function kl(r){const t=ys,e=BigInt(3),n=BigInt(6),i=BigInt(11),o=BigInt(22),s=BigInt(23),a=BigInt(44),c=BigInt(88),u=r*r*r%t,l=u*u*r%t,h=St(l,e,t)*l%t,y=St(h,e,t)*l%t,f=St(y,gi,t)*u%t,p=St(f,i,t)*f%t,d=St(p,o,t)*p%t,g=St(d,a,t)*d%t,S=St(g,c,t)*g%t,B=St(S,a,t)*d%t,x=St(B,e,t)*l%t,C=St(x,s,t)*p%t,E=St(C,n,t)*u%t,I=St(E,gi,t);if(!yi.eql(yi.sqr(I),r))throw new Error("Cannot find square root");return I}const yi=Bo(ys,void 0,void 0,{sqrt:kl}),mi=xl({a:BigInt(0),b:BigInt(7),Fp:yi,n:ms,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:r=>{const t=ms,e=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-El*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=e,s=BigInt("0x100000000000000000000000000000000"),a=bs(o*r,t),c=bs(-n*r,t);let u=pt(r-a*e-c*i,t),l=pt(-a*n-c*o,t);const h=u>s,y=l>s;if(h&&(u=t-u),y&&(l=t-l),u>s||l>s)throw new Error("splitScalar: Endomorphism failed, k="+r);return{k1neg:h,k1:u,k2neg:y,k2:l}}}},Gn);BigInt(0),mi.ProjectivePoint;const ws=()=>{const r=Cr.utils.randomPrivateKey(),t=bi(r),e=new Uint8Array(64);return e.set(r),e.set(t,32),{publicKey:t,secretKey:e}},bi=Cr.getPublicKey;function vs(r){try{return Cr.ExtendedPoint.fromHex(r),!0}catch{return!1}}const Bl=(r,t)=>Cr.sign(r,t.slice(0,32)),Al=Cr.verify,Rt=r=>Y.isBuffer(r)?r:r instanceof Uint8Array?Y.from(r.buffer,r.byteOffset,r.byteLength):Y.from(r);class Il{constructor(t){Object.assign(this,t)}encode(){return Y.from(zo(hn,this))}static decode(t){return Ho(hn,this,t)}static decodeUnchecked(t){return Oo(hn,this,t)}}const hn=new Map;var Ss;const _l=32,Re=32;function Ll(r){return r._bn!==void 0}let xs=1;class q extends Il{constructor(t){if(super({}),this._bn=void 0,Ll(t))this._bn=t._bn;else{if(typeof t=="string"){const e=Ct.decode(t);if(e.length!=Re)throw new Error("Invalid public key input");this._bn=new so(e)}else this._bn=new so(t);if(this._bn.byteLength()>Re)throw new Error("Invalid public key input")}}static unique(){const t=new q(xs);return xs+=1,new q(t.toBuffer())}equals(t){return this._bn.eq(t._bn)}toBase58(){return Ct.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const t=this.toBuffer();return new Uint8Array(t.buffer,t.byteOffset,t.byteLength)}toBuffer(){const t=this._bn.toArrayLike(Y);if(t.length===Re)return t;const e=Y.alloc(32);return t.copy(e,32-t.length),e}get[Symbol.toStringTag](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(t,e,n){const i=Y.concat([t.toBuffer(),Y.from(e),n.toBuffer()]),o=Gn(i);return new q(o)}static createProgramAddressSync(t,e){let n=Y.alloc(0);t.forEach(function(o){if(o.length>_l)throw new TypeError("Max seed length exceeded");n=Y.concat([n,Rt(o)])}),n=Y.concat([n,e.toBuffer(),Y.from("ProgramDerivedAddress")]);const i=Gn(n);if(vs(i))throw new Error("Invalid seeds, address must fall off the curve");return new q(i)}static async createProgramAddress(t,e){return this.createProgramAddressSync(t,e)}static findProgramAddressSync(t,e){let n=255,i;for(;n!=0;){try{const o=t.concat(Y.from([n]));i=this.createProgramAddressSync(o,e)}catch(o){if(o instanceof TypeError)throw o;n--;continue}return[i,n]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(t,e){return this.findProgramAddressSync(t,e)}static isOnCurve(t){const e=new q(t);return vs(e.toBytes())}}Ss=q,q.default=new Ss("11111111111111111111111111111111"),hn.set(q,{kind:"struct",fields:[["_bn","u256"]]}),new q("BPFLoader1111111111111111111111111111111111");const pr=1232,Es=127,ks=64;class Bs extends Error{constructor(t){super(`Signature ${t} has expired: block height exceeded.`),this.signature=void 0,this.signature=t}}Object.defineProperty(Bs.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});class As extends Error{constructor(t,e){super(`Transaction was not confirmed in ${e.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${t} using the Solana Explorer or CLI tools.`),this.signature=void 0,this.signature=t}}Object.defineProperty(As.prototype,"name",{value:"TransactionExpiredTimeoutError"});class Nr extends Error{constructor(t){super(`Signature ${t} has expired: the nonce is no longer valid.`),this.signature=void 0,this.signature=t}}Object.defineProperty(Nr.prototype,"name",{value:"TransactionExpiredNonceInvalidError"});class dn{constructor(t,e){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=t,this.accountKeysFromLookups=e}keySegments(){const t=[this.staticAccountKeys];return this.accountKeysFromLookups&&(t.push(this.accountKeysFromLookups.writable),t.push(this.accountKeysFromLookups.readonly)),t}get(t){for(const e of this.keySegments()){if(t<e.length)return e[t];t-=e.length}}get length(){return this.keySegments().flat().length}compileInstructions(t){if(this.length>256)throw new Error("Account index overflow encountered during compilation");const e=new Map;this.keySegments().flat().forEach((i,o)=>{e.set(i.toBase58(),o)});const n=i=>{const o=e.get(i.toBase58());if(o===void 0)throw new Error("Encountered an unknown instruction account key during compilation");return o};return t.map(i=>({programIdIndex:n(i.programId),accountKeyIndexes:i.keys.map(o=>n(o.pubkey)),data:i.data}))}}const it=(r="publicKey")=>gt(32,r),gr=(r="string")=>{const t=W([j("length"),j("lengthPadding"),gt(Qe(j(),-8),"chars")],r),e=t.decode.bind(t),n=t.encode.bind(t),i=t;return i.decode=(o,s)=>e(o,s).chars.toString(),i.encode=(o,s,a)=>{const c={chars:Y.from(o,"utf8")};return n(c,s,a)},i.alloc=o=>j().span+j().span+Y.from(o,"utf8").length,i},Cl=(r="authorized")=>W([it("staker"),it("withdrawer")],r),Tl=(r="lockup")=>W([Zt("unixTimestamp"),Zt("epoch"),it("custodian")],r),Ol=(r="voteInit")=>W([it("nodePubkey"),it("authorizedVoter"),it("authorizedWithdrawer"),nt("commission")],r),Pl=(r="voteAuthorizeWithSeedArgs")=>W([j("voteAuthorizationType"),it("currentAuthorityDerivedKeyOwnerPubkey"),gr("currentAuthorityDerivedKeySeed"),it("newAuthorized")],r);function Is(r,t){const e=i=>{if(i.span>=0)return i.span;if(typeof i.alloc=="function")return i.alloc(t[i.property]);if("count"in i&&"elementLayout"in i){const o=t[i.property];if(Array.isArray(o))return o.length*e(i.elementLayout)}else if("fields"in i)return Is({layout:i},t[i.property]);return 0};let n=0;return r.layout.fields.forEach(i=>{n+=e(i)}),n}function ee(r){let t=0,e=0;for(;;){let n=r.shift();if(t|=(n&127)<<e*7,e+=1,!(n&128))break}return t}function re(r,t){let e=t;for(;;){let n=e&127;if(e>>=7,e==0){r.push(n);break}else n|=128,r.push(n)}}function kt(r,t){if(!r)throw new Error(t||"Assertion failed")}class Bn{constructor(t,e){this.payer=void 0,this.keyMetaMap=void 0,this.payer=t,this.keyMetaMap=e}static compile(t,e){const n=new Map,i=s=>{const a=s.toBase58();let c=n.get(a);return c===void 0&&(c={isSigner:!1,isWritable:!1,isInvoked:!1},n.set(a,c)),c},o=i(e);o.isSigner=!0,o.isWritable=!0;for(const s of t){i(s.programId).isInvoked=!0;for(const a of s.keys){const c=i(a.pubkey);c.isSigner||(c.isSigner=a.isSigner),c.isWritable||(c.isWritable=a.isWritable)}}return new Bn(e,n)}getMessageComponents(){const t=[...this.keyMetaMap.entries()];kt(t.length<=256,"Max static account keys length exceeded");const e=t.filter(([,c])=>c.isSigner&&c.isWritable),n=t.filter(([,c])=>c.isSigner&&!c.isWritable),i=t.filter(([,c])=>!c.isSigner&&c.isWritable),o=t.filter(([,c])=>!c.isSigner&&!c.isWritable),s={numRequiredSignatures:e.length+n.length,numReadonlySignedAccounts:n.length,numReadonlyUnsignedAccounts:o.length};{kt(e.length>0,"Expected at least one writable signer key");const[c]=e[0];kt(c===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}const a=[...e.map(([c])=>new q(c)),...n.map(([c])=>new q(c)),...i.map(([c])=>new q(c)),...o.map(([c])=>new q(c))];return[s,a]}extractTableLookup(t){const[e,n]=this.drainKeysFoundInLookupTable(t.state.addresses,s=>!s.isSigner&&!s.isInvoked&&s.isWritable),[i,o]=this.drainKeysFoundInLookupTable(t.state.addresses,s=>!s.isSigner&&!s.isInvoked&&!s.isWritable);if(!(e.length===0&&i.length===0))return[{accountKey:t.key,writableIndexes:e,readonlyIndexes:i},{writable:n,readonly:o}]}drainKeysFoundInLookupTable(t,e){const n=new Array,i=new Array;for(const[o,s]of this.keyMetaMap.entries())if(e(s)){const a=new q(o),c=t.findIndex(u=>u.equals(a));c>=0&&(kt(c<256,"Max lookup table index exceeded"),n.push(c),i.push(a),this.keyMetaMap.delete(o))}return[n,i]}}const _s="Reached end of buffer unexpectedly";function xe(r){if(r.length===0)throw new Error(_s);return r.shift()}function ne(r,...t){const[e]=t;if(t.length===2?e+(t[1]??0)>r.length:e>=r.length)throw new Error(_s);return r.splice(...t)}class $e{constructor(t){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=t.header,this.accountKeys=t.accountKeys.map(e=>new q(e)),this.recentBlockhash=t.recentBlockhash,this.instructions=t.instructions,this.instructions.forEach(e=>this.indexToProgramIds.set(e.programIdIndex,this.accountKeys[e.programIdIndex]))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map(t=>({programIdIndex:t.programIdIndex,accountKeyIndexes:t.accounts,data:Ct.decode(t.data)}))}get addressTableLookups(){return[]}getAccountKeys(){return new dn(this.staticAccountKeys)}static compile(t){const e=Bn.compile(t.instructions,t.payerKey),[n,i]=e.getMessageComponents(),o=new dn(i).compileInstructions(t.instructions).map(s=>({programIdIndex:s.programIdIndex,accounts:s.accountKeyIndexes,data:Ct.encode(s.data)}));return new $e({header:n,accountKeys:i,recentBlockhash:t.recentBlockhash,instructions:o})}isAccountSigner(t){return t<this.header.numRequiredSignatures}isAccountWritable(t){const e=this.header.numRequiredSignatures;if(t>=this.header.numRequiredSignatures){const n=t-e,i=this.accountKeys.length-e-this.header.numReadonlyUnsignedAccounts;return n<i}else{const n=e-this.header.numReadonlySignedAccounts;return t<n}}isProgramId(t){return this.indexToProgramIds.has(t)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter((t,e)=>!this.isProgramId(e))}serialize(){const t=this.accountKeys.length;let e=[];re(e,t);const n=this.instructions.map(h=>{const{accounts:y,programIdIndex:f}=h,p=Array.from(Ct.decode(h.data));let d=[];re(d,y.length);let g=[];return re(g,p.length),{programIdIndex:f,keyIndicesCount:Y.from(d),keyIndices:y,dataLength:Y.from(g),data:p}});let i=[];re(i,n.length);let o=Y.alloc(pr);Y.from(i).copy(o);let s=i.length;n.forEach(h=>{const y=W([nt("programIdIndex"),gt(h.keyIndicesCount.length,"keyIndicesCount"),$t(nt("keyIndex"),h.keyIndices.length,"keyIndices"),gt(h.dataLength.length,"dataLength"),$t(nt("userdatum"),h.data.length,"data")]).encode(h,o,s);s+=y}),o=o.slice(0,s);const a=W([gt(1,"numRequiredSignatures"),gt(1,"numReadonlySignedAccounts"),gt(1,"numReadonlyUnsignedAccounts"),gt(e.length,"keyCount"),$t(it("key"),t,"keys"),it("recentBlockhash")]),c={numRequiredSignatures:Y.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:Y.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:Y.from([this.header.numReadonlyUnsignedAccounts]),keyCount:Y.from(e),keys:this.accountKeys.map(h=>Rt(h.toBytes())),recentBlockhash:Ct.decode(this.recentBlockhash)};let u=Y.alloc(2048);const l=a.encode(c,u);return o.copy(u,l),u.slice(0,l+o.length)}static from(t){let e=[...t];const n=xe(e);if(n!==(n&Es))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const i=xe(e),o=xe(e),s=ee(e);let a=[];for(let y=0;y<s;y++){const f=ne(e,0,Re);a.push(new q(Y.from(f)))}const c=ne(e,0,Re),u=ee(e);let l=[];for(let y=0;y<u;y++){const f=xe(e),p=ee(e),d=ne(e,0,p),g=ee(e),S=ne(e,0,g),B=Ct.encode(Y.from(S));l.push({programIdIndex:f,accounts:d,data:B})}const h={header:{numRequiredSignatures:n,numReadonlySignedAccounts:i,numReadonlyUnsignedAccounts:o},recentBlockhash:Ct.encode(Y.from(c)),accountKeys:a,instructions:l};return new $e(h)}}class An{constructor(t){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=t.header,this.staticAccountKeys=t.staticAccountKeys,this.recentBlockhash=t.recentBlockhash,this.compiledInstructions=t.compiledInstructions,this.addressTableLookups=t.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let t=0;for(const e of this.addressTableLookups)t+=e.readonlyIndexes.length+e.writableIndexes.length;return t}getAccountKeys(t){let e;if(t&&"accountKeysFromLookups"in t&&t.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=t.accountKeysFromLookups.writable.length+t.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");e=t.accountKeysFromLookups}else if(t&&"addressLookupTableAccounts"in t&&t.addressLookupTableAccounts)e=this.resolveAddressTableLookups(t.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new dn(this.staticAccountKeys,e)}isAccountSigner(t){return t<this.header.numRequiredSignatures}isAccountWritable(t){const e=this.header.numRequiredSignatures,n=this.staticAccountKeys.length;if(t>=n){const i=t-n,o=this.addressTableLookups.reduce((s,a)=>s+a.writableIndexes.length,0);return i<o}else if(t>=this.header.numRequiredSignatures){const i=t-e,o=n-e-this.header.numReadonlyUnsignedAccounts;return i<o}else{const i=e-this.header.numReadonlySignedAccounts;return t<i}}resolveAddressTableLookups(t){const e={writable:[],readonly:[]};for(const n of this.addressTableLookups){const i=t.find(o=>o.key.equals(n.accountKey));if(!i)throw new Error(`Failed to find address lookup table account for table key ${n.accountKey.toBase58()}`);for(const o of n.writableIndexes)if(o<i.state.addresses.length)e.writable.push(i.state.addresses[o]);else throw new Error(`Failed to find address for index ${o} in address lookup table ${n.accountKey.toBase58()}`);for(const o of n.readonlyIndexes)if(o<i.state.addresses.length)e.readonly.push(i.state.addresses[o]);else throw new Error(`Failed to find address for index ${o} in address lookup table ${n.accountKey.toBase58()}`)}return e}static compile(t){const e=Bn.compile(t.instructions,t.payerKey),n=new Array,i={writable:new Array,readonly:new Array},o=t.addressLookupTableAccounts||[];for(const u of o){const l=e.extractTableLookup(u);if(l!==void 0){const[h,{writable:y,readonly:f}]=l;n.push(h),i.writable.push(...y),i.readonly.push(...f)}}const[s,a]=e.getMessageComponents(),c=new dn(a,i).compileInstructions(t.instructions);return new An({header:s,staticAccountKeys:a,recentBlockhash:t.recentBlockhash,compiledInstructions:c,addressTableLookups:n})}serialize(){const t=Array();re(t,this.staticAccountKeys.length);const e=this.serializeInstructions(),n=Array();re(n,this.compiledInstructions.length);const i=this.serializeAddressTableLookups(),o=Array();re(o,this.addressTableLookups.length);const s=W([nt("prefix"),W([nt("numRequiredSignatures"),nt("numReadonlySignedAccounts"),nt("numReadonlyUnsignedAccounts")],"header"),gt(t.length,"staticAccountKeysLength"),$t(it(),this.staticAccountKeys.length,"staticAccountKeys"),it("recentBlockhash"),gt(n.length,"instructionsLength"),gt(e.length,"serializedInstructions"),gt(o.length,"addressTableLookupsLength"),gt(i.length,"serializedAddressTableLookups")]),a=new Uint8Array(pr),c=s.encode({prefix:128,header:this.header,staticAccountKeysLength:new Uint8Array(t),staticAccountKeys:this.staticAccountKeys.map(u=>u.toBytes()),recentBlockhash:Ct.decode(this.recentBlockhash),instructionsLength:new Uint8Array(n),serializedInstructions:e,addressTableLookupsLength:new Uint8Array(o),serializedAddressTableLookups:i},a);return a.slice(0,c)}serializeInstructions(){let t=0;const e=new Uint8Array(pr);for(const n of this.compiledInstructions){const i=Array();re(i,n.accountKeyIndexes.length);const o=Array();re(o,n.data.length);const s=W([nt("programIdIndex"),gt(i.length,"encodedAccountKeyIndexesLength"),$t(nt(),n.accountKeyIndexes.length,"accountKeyIndexes"),gt(o.length,"encodedDataLength"),gt(n.data.length,"data")]);t+=s.encode({programIdIndex:n.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(i),accountKeyIndexes:n.accountKeyIndexes,encodedDataLength:new Uint8Array(o),data:n.data},e,t)}return e.slice(0,t)}serializeAddressTableLookups(){let t=0;const e=new Uint8Array(pr);for(const n of this.addressTableLookups){const i=Array();re(i,n.writableIndexes.length);const o=Array();re(o,n.readonlyIndexes.length);const s=W([it("accountKey"),gt(i.length,"encodedWritableIndexesLength"),$t(nt(),n.writableIndexes.length,"writableIndexes"),gt(o.length,"encodedReadonlyIndexesLength"),$t(nt(),n.readonlyIndexes.length,"readonlyIndexes")]);t+=s.encode({accountKey:n.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(i),writableIndexes:n.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(o),readonlyIndexes:n.readonlyIndexes},e,t)}return e.slice(0,t)}static deserialize(t){let e=[...t];const n=xe(e),i=n&Es;kt(n!==i,"Expected versioned message but received legacy message");const o=i;kt(o===0,`Expected versioned message with version 0 but found version ${o}`);const s={numRequiredSignatures:xe(e),numReadonlySignedAccounts:xe(e),numReadonlyUnsignedAccounts:xe(e)},a=[],c=ee(e);for(let p=0;p<c;p++)a.push(new q(ne(e,0,Re)));const u=Ct.encode(ne(e,0,Re)),l=ee(e),h=[];for(let p=0;p<l;p++){const d=xe(e),g=ee(e),S=ne(e,0,g),B=ee(e),x=new Uint8Array(ne(e,0,B));h.push({programIdIndex:d,accountKeyIndexes:S,data:x})}const y=ee(e),f=[];for(let p=0;p<y;p++){const d=new q(ne(e,0,Re)),g=ee(e),S=ne(e,0,g),B=ee(e),x=ne(e,0,B);f.push({accountKey:d,writableIndexes:S,readonlyIndexes:x})}return new An({header:s,staticAccountKeys:a,recentBlockhash:u,compiledInstructions:h,addressTableLookups:f})}}let Ue=function(r){return r[r.BLOCKHEIGHT_EXCEEDED=0]="BLOCKHEIGHT_EXCEEDED",r[r.PROCESSED=1]="PROCESSED",r[r.TIMED_OUT=2]="TIMED_OUT",r[r.NONCE_INVALID=3]="NONCE_INVALID",r}({});const Rl=Y.alloc(ks).fill(0);class Jt{constructor(t){this.keys=void 0,this.programId=void 0,this.data=Y.alloc(0),this.programId=t.programId,this.keys=t.keys,t.data&&(this.data=t.data)}toJSON(){return{keys:this.keys.map(({pubkey:t,isSigner:e,isWritable:n})=>({pubkey:t.toJSON(),isSigner:e,isWritable:n})),programId:this.programId.toJSON(),data:[...this.data]}}}class le{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(t){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,!!t)if(t.feePayer&&(this.feePayer=t.feePayer),t.signatures&&(this.signatures=t.signatures),Object.prototype.hasOwnProperty.call(t,"nonceInfo")){const{minContextSlot:e,nonceInfo:n}=t;this.minNonceContextSlot=e,this.nonceInfo=n}else if(Object.prototype.hasOwnProperty.call(t,"lastValidBlockHeight")){const{blockhash:e,lastValidBlockHeight:n}=t;this.recentBlockhash=e,this.lastValidBlockHeight=n}else{const{recentBlockhash:e,nonceInfo:n}=t;n&&(this.nonceInfo=n),this.recentBlockhash=e}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map(t=>t.toJSON()),signers:this.signatures.map(({publicKey:t})=>t.toJSON())}}add(...t){if(t.length===0)throw new Error("No instructions");return t.forEach(e=>{"instructions"in e?this.instructions=this.instructions.concat(e.instructions):"data"in e&&"programId"in e&&"keys"in e?this.instructions.push(e):this.instructions.push(new Jt(e))}),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let t,e;if(this.nonceInfo?(t=this.nonceInfo.nonce,this.instructions[0]!=this.nonceInfo.nonceInstruction?e=[this.nonceInfo.nonceInstruction,...this.instructions]:e=this.instructions):(t=this.recentBlockhash,e=this.instructions),!t)throw new Error("Transaction recentBlockhash required");e.length<1&&console.warn("No instructions provided");let n;if(this.feePayer)n=this.feePayer;else if(this.signatures.length>0&&this.signatures[0].publicKey)n=this.signatures[0].publicKey;else throw new Error("Transaction fee payer required");for(let d=0;d<e.length;d++)if(e[d].programId===void 0)throw new Error(`Transaction instruction index ${d} has undefined program id`);const i=[],o=[];e.forEach(d=>{d.keys.forEach(S=>{o.push({...S})});const g=d.programId.toString();i.includes(g)||i.push(g)}),i.forEach(d=>{o.push({pubkey:new q(d),isSigner:!1,isWritable:!1})});const s=[];o.forEach(d=>{const g=d.pubkey.toString(),S=s.findIndex(B=>B.pubkey.toString()===g);S>-1?(s[S].isWritable=s[S].isWritable||d.isWritable,s[S].isSigner=s[S].isSigner||d.isSigner):s.push(d)}),s.sort(function(d,g){if(d.isSigner!==g.isSigner)return d.isSigner?-1:1;if(d.isWritable!==g.isWritable)return d.isWritable?-1:1;const S={localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"};return d.pubkey.toBase58().localeCompare(g.pubkey.toBase58(),"en",S)});const a=s.findIndex(d=>d.pubkey.equals(n));if(a>-1){const[d]=s.splice(a,1);d.isSigner=!0,d.isWritable=!0,s.unshift(d)}else s.unshift({pubkey:n,isSigner:!0,isWritable:!0});for(const d of this.signatures){const g=s.findIndex(S=>S.pubkey.equals(d.publicKey));if(g>-1)s[g].isSigner||(s[g].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));else throw new Error(`unknown signer: ${d.publicKey.toString()}`)}let c=0,u=0,l=0;const h=[],y=[];s.forEach(({pubkey:d,isSigner:g,isWritable:S})=>{g?(h.push(d.toString()),c+=1,S||(u+=1)):(y.push(d.toString()),S||(l+=1))});const f=h.concat(y),p=e.map(d=>{const{data:g,programId:S}=d;return{programIdIndex:f.indexOf(S.toString()),accounts:d.keys.map(B=>f.indexOf(B.pubkey.toString())),data:Ct.encode(g)}});return p.forEach(d=>{kt(d.programIdIndex>=0),d.accounts.forEach(g=>kt(g>=0))}),new $e({header:{numRequiredSignatures:c,numReadonlySignedAccounts:u,numReadonlyUnsignedAccounts:l},accountKeys:f,recentBlockhash:t,instructions:p})}_compile(){const t=this.compileMessage(),e=t.accountKeys.slice(0,t.header.numRequiredSignatures);return this.signatures.length===e.length&&this.signatures.every((n,i)=>e[i].equals(n.publicKey))||(this.signatures=e.map(n=>({signature:null,publicKey:n}))),t}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(t){return(await t.getFeeForMessage(this.compileMessage())).value}setSigners(...t){if(t.length===0)throw new Error("No signers");const e=new Set;this.signatures=t.filter(n=>{const i=n.toString();return e.has(i)?!1:(e.add(i),!0)}).map(n=>({signature:null,publicKey:n}))}sign(...t){if(t.length===0)throw new Error("No signers");const e=new Set,n=[];for(const o of t){const s=o.publicKey.toString();e.has(s)||(e.add(s),n.push(o))}this.signatures=n.map(o=>({signature:null,publicKey:o.publicKey}));const i=this._compile();this._partialSign(i,...n)}partialSign(...t){if(t.length===0)throw new Error("No signers");const e=new Set,n=[];for(const o of t){const s=o.publicKey.toString();e.has(s)||(e.add(s),n.push(o))}const i=this._compile();this._partialSign(i,...n)}_partialSign(t,...e){const n=t.serialize();e.forEach(i=>{const o=Bl(n,i.secretKey);this._addSignature(i.publicKey,Rt(o))})}addSignature(t,e){this._compile(),this._addSignature(t,e)}_addSignature(t,e){kt(e.length===64);const n=this.signatures.findIndex(i=>t.equals(i.publicKey));if(n<0)throw new Error(`unknown signer: ${t.toString()}`);this.signatures[n].signature=Y.from(e)}verifySignatures(t=!0){return!this._getMessageSignednessErrors(this.serializeMessage(),t)}_getMessageSignednessErrors(t,e){const n={};for(const{signature:i,publicKey:o}of this.signatures)i===null?e&&(n.missing||(n.missing=[])).push(o):Al(i,t,o.toBytes())||(n.invalid||(n.invalid=[])).push(o);return n.invalid||n.missing?n:void 0}serialize(t){const{requireAllSignatures:e,verifySignatures:n}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},t),i=this.serializeMessage();if(n){const o=this._getMessageSignednessErrors(i,e);if(o){let s="Signature verification failed.";throw o.invalid&&(s+=`
Invalid signature for public key${o.invalid.length===1?"":"(s)"} [\`${o.invalid.map(a=>a.toBase58()).join("`, `")}\`].`),o.missing&&(s+=`
Missing signature for public key${o.missing.length===1?"":"(s)"} [\`${o.missing.map(a=>a.toBase58()).join("`, `")}\`].`),new Error(s)}}return this._serialize(i)}_serialize(t){const{signatures:e}=this,n=[];re(n,e.length);const i=n.length+e.length*64+t.length,o=Y.alloc(i);return kt(e.length<256),Y.from(n).copy(o,0),e.forEach(({signature:s},a)=>{s!==null&&(kt(s.length===64,"signature has invalid length"),Y.from(s).copy(o,n.length+a*64))}),t.copy(o,n.length+e.length*64),kt(o.length<=pr,`Transaction too large: ${o.length} > ${pr}`),o}get keys(){return kt(this.instructions.length===1),this.instructions[0].keys.map(t=>t.pubkey)}get programId(){return kt(this.instructions.length===1),this.instructions[0].programId}get data(){return kt(this.instructions.length===1),this.instructions[0].data}static from(t){let e=[...t];const n=ee(e);let i=[];for(let o=0;o<n;o++){const s=ne(e,0,ks);i.push(Ct.encode(Y.from(s)))}return le.populate($e.from(e),i)}static populate(t,e=[]){const n=new le;return n.recentBlockhash=t.recentBlockhash,t.header.numRequiredSignatures>0&&(n.feePayer=t.accountKeys[0]),e.forEach((i,o)=>{const s={signature:i==Ct.encode(Rl)?null:Ct.decode(i),publicKey:t.accountKeys[o]};n.signatures.push(s)}),t.instructions.forEach(i=>{const o=i.accounts.map(s=>{const a=t.accountKeys[s];return{pubkey:a,isSigner:n.signatures.some(c=>c.publicKey.toString()===a.toString())||t.isAccountSigner(s),isWritable:t.isAccountWritable(s)}});n.instructions.push(new Jt({keys:o,programId:t.accountKeys[i.programIdIndex],data:Ct.decode(i.data)}))}),n._message=t,n._json=n.toJSON(),n}}const Ul=160,Nl=64,zl=Ul/Nl,Hl=1e3/zl;new q("SysvarC1ock11111111111111111111111111111111"),new q("SysvarEpochSchedu1e111111111111111111111111"),new q("Sysvar1nstructions1111111111111111111111111");const wi=new q("SysvarRecentB1ockHashes11111111111111111111"),Ls=new q("SysvarRent111111111111111111111111111111111");new q("SysvarRewards111111111111111111111111111111"),new q("SysvarS1otHashes111111111111111111111111111"),new q("SysvarS1otHistory11111111111111111111111111"),new q("SysvarStakeHistory1111111111111111111111111");class vi extends Error{constructor({action:t,signature:e,transactionMessage:n,logs:i}){const o=i?`Logs: 
${JSON.stringify(i.slice(-10),null,2)}. `:"",s="\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.";let a;switch(t){case"send":a=`Transaction ${e} resulted in an error. 
${n}. `+o+s;break;case"simulate":a=`Simulation failed. 
Message: ${n}. 
`+o+s;break;default:a=`Unknown action '${(c=>c)(t)}'`}super(a),this.signature=void 0,this.transactionMessage=void 0,this.transactionLogs=void 0,this.signature=e,this.transactionMessage=n,this.transactionLogs=i||void 0}get transactionError(){return{message:this.transactionMessage,logs:Array.isArray(this.transactionLogs)?this.transactionLogs:void 0}}get logs(){const t=this.transactionLogs;if(!(t!=null&&typeof t=="object"&&"then"in t))return t}async getLogs(t){return Array.isArray(this.transactionLogs)||(this.transactionLogs=new Promise((e,n)=>{t.getTransaction(this.signature).then(i=>{if(i&&i.meta&&i.meta.logMessages){const o=i.meta.logMessages;this.transactionLogs=o,e(o)}else n(new Error("Log messages not found"))}).catch(n)})),await this.transactionLogs}}class M extends Error{constructor({code:t,message:e,data:n},i){super(i!=null?`${i}: ${e}`:e),this.code=void 0,this.data=void 0,this.code=t,this.data=n,this.name="SolanaJSONRPCError"}}async function ql(r,t,e,n){const i=n&&{skipPreflight:n.skipPreflight,preflightCommitment:n.preflightCommitment||n.commitment,maxRetries:n.maxRetries,minContextSlot:n.minContextSlot},o=await r.sendTransaction(t,e,i);let s;if(t.recentBlockhash!=null&&t.lastValidBlockHeight!=null)s=(await r.confirmTransaction({abortSignal:n==null?void 0:n.abortSignal,signature:o,blockhash:t.recentBlockhash,lastValidBlockHeight:t.lastValidBlockHeight},n&&n.commitment)).value;else if(t.minNonceContextSlot!=null&&t.nonceInfo!=null){const{nonceInstruction:a}=t.nonceInfo,c=a.keys[0].pubkey;s=(await r.confirmTransaction({abortSignal:n==null?void 0:n.abortSignal,minContextSlot:t.minNonceContextSlot,nonceAccountPubkey:c,nonceValue:t.nonceInfo.nonce,signature:o},n&&n.commitment)).value}else(n==null?void 0:n.abortSignal)!=null&&console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable."),s=(await r.confirmTransaction(o,n&&n.commitment)).value;if(s.err)throw o!=null?new vi({action:"send",signature:o,transactionMessage:`Status: (${JSON.stringify(s)})`}):new Error(`Transaction ${o} failed (${JSON.stringify(s)})`);return o}function yr(r){return new Promise(t=>setTimeout(t,r))}function ie(r,t){const e=r.layout.span>=0?r.layout.span:Is(r,t),n=Y.alloc(e),i=Object.assign({instruction:r.index},t);return r.layout.encode(i,n),n}const Fl=Ot("lamportsPerSignature"),Cs=W([j("version"),j("state"),it("authorizedPubkey"),it("nonce"),W([Fl],"feeCalculator")]),Ts=Cs.span;class eo{constructor(t){this.authorizedPubkey=void 0,this.nonce=void 0,this.feeCalculator=void 0,this.authorizedPubkey=t.authorizedPubkey,this.nonce=t.nonce,this.feeCalculator=t.feeCalculator}static fromAccountData(t){const e=Cs.decode(Rt(t),0);return new eo({authorizedPubkey:new q(e.authorizedPubkey),nonce:new q(e.nonce).toString(),feeCalculator:e.feeCalculator})}}const Kl=r=>{const t=r.decode.bind(r),e=r.encode.bind(r);return{decode:t,encode:e}},Wl=r=>t=>{const e=gt(r,t),{encode:n,decode:i}=Kl(e),o=e;return o.decode=(s,a)=>{const c=i(s,a);return rs(Y.from(c))},o.encode=(s,a,c)=>{const u=ns(s,r);return n(u,a,c)},o},mr=Wl(8),oe=Object.freeze({Create:{index:0,layout:W([j("instruction"),Zt("lamports"),Zt("space"),it("programId")])},Assign:{index:1,layout:W([j("instruction"),it("programId")])},Transfer:{index:2,layout:W([j("instruction"),mr("lamports")])},CreateWithSeed:{index:3,layout:W([j("instruction"),it("base"),gr("seed"),Zt("lamports"),Zt("space"),it("programId")])},AdvanceNonceAccount:{index:4,layout:W([j("instruction")])},WithdrawNonceAccount:{index:5,layout:W([j("instruction"),Zt("lamports")])},InitializeNonceAccount:{index:6,layout:W([j("instruction"),it("authorized")])},AuthorizeNonceAccount:{index:7,layout:W([j("instruction"),it("authorized")])},Allocate:{index:8,layout:W([j("instruction"),Zt("space")])},AllocateWithSeed:{index:9,layout:W([j("instruction"),it("base"),gr("seed"),Zt("space"),it("programId")])},AssignWithSeed:{index:10,layout:W([j("instruction"),it("base"),gr("seed"),it("programId")])},TransferWithSeed:{index:11,layout:W([j("instruction"),mr("lamports"),gr("seed"),it("programId")])},UpgradeNonceAccount:{index:12,layout:W([j("instruction")])}});class vr{constructor(){}static createAccount(t){const e=oe.Create,n=ie(e,{lamports:t.lamports,space:t.space,programId:Rt(t.programId.toBuffer())});return new Jt({keys:[{pubkey:t.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:t.newAccountPubkey,isSigner:!0,isWritable:!0}],programId:this.programId,data:n})}static transfer(t){let e,n;if("basePubkey"in t){const i=oe.TransferWithSeed;e=ie(i,{lamports:BigInt(t.lamports),seed:t.seed,programId:Rt(t.programId.toBuffer())}),n=[{pubkey:t.fromPubkey,isSigner:!1,isWritable:!0},{pubkey:t.basePubkey,isSigner:!0,isWritable:!1},{pubkey:t.toPubkey,isSigner:!1,isWritable:!0}]}else{const i=oe.Transfer;e=ie(i,{lamports:BigInt(t.lamports)}),n=[{pubkey:t.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:t.toPubkey,isSigner:!1,isWritable:!0}]}return new Jt({keys:n,programId:this.programId,data:e})}static assign(t){let e,n;if("basePubkey"in t){const i=oe.AssignWithSeed;e=ie(i,{base:Rt(t.basePubkey.toBuffer()),seed:t.seed,programId:Rt(t.programId.toBuffer())}),n=[{pubkey:t.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:t.basePubkey,isSigner:!0,isWritable:!1}]}else{const i=oe.Assign;e=ie(i,{programId:Rt(t.programId.toBuffer())}),n=[{pubkey:t.accountPubkey,isSigner:!0,isWritable:!0}]}return new Jt({keys:n,programId:this.programId,data:e})}static createAccountWithSeed(t){const e=oe.CreateWithSeed,n=ie(e,{base:Rt(t.basePubkey.toBuffer()),seed:t.seed,lamports:t.lamports,space:t.space,programId:Rt(t.programId.toBuffer())});let i=[{pubkey:t.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:t.newAccountPubkey,isSigner:!1,isWritable:!0}];return t.basePubkey!=t.fromPubkey&&i.push({pubkey:t.basePubkey,isSigner:!0,isWritable:!1}),new Jt({keys:i,programId:this.programId,data:n})}static createNonceAccount(t){const e=new le;"basePubkey"in t&&"seed"in t?e.add(vr.createAccountWithSeed({fromPubkey:t.fromPubkey,newAccountPubkey:t.noncePubkey,basePubkey:t.basePubkey,seed:t.seed,lamports:t.lamports,space:Ts,programId:this.programId})):e.add(vr.createAccount({fromPubkey:t.fromPubkey,newAccountPubkey:t.noncePubkey,lamports:t.lamports,space:Ts,programId:this.programId}));const n={noncePubkey:t.noncePubkey,authorizedPubkey:t.authorizedPubkey};return e.add(this.nonceInitialize(n)),e}static nonceInitialize(t){const e=oe.InitializeNonceAccount,n=ie(e,{authorized:Rt(t.authorizedPubkey.toBuffer())}),i={keys:[{pubkey:t.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:wi,isSigner:!1,isWritable:!1},{pubkey:Ls,isSigner:!1,isWritable:!1}],programId:this.programId,data:n};return new Jt(i)}static nonceAdvance(t){const e=oe.AdvanceNonceAccount,n=ie(e),i={keys:[{pubkey:t.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:wi,isSigner:!1,isWritable:!1},{pubkey:t.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:n};return new Jt(i)}static nonceWithdraw(t){const e=oe.WithdrawNonceAccount,n=ie(e,{lamports:t.lamports});return new Jt({keys:[{pubkey:t.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:t.toPubkey,isSigner:!1,isWritable:!0},{pubkey:wi,isSigner:!1,isWritable:!1},{pubkey:Ls,isSigner:!1,isWritable:!1},{pubkey:t.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:n})}static nonceAuthorize(t){const e=oe.AuthorizeNonceAccount,n=ie(e,{authorized:Rt(t.newAuthorizedPubkey.toBuffer())});return new Jt({keys:[{pubkey:t.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:t.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:n})}static allocate(t){let e,n;if("basePubkey"in t){const i=oe.AllocateWithSeed;e=ie(i,{base:Rt(t.basePubkey.toBuffer()),seed:t.seed,space:t.space,programId:Rt(t.programId.toBuffer())}),n=[{pubkey:t.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:t.basePubkey,isSigner:!0,isWritable:!1}]}else{const i=oe.Allocate;e=ie(i,{space:t.space}),n=[{pubkey:t.accountPubkey,isSigner:!0,isWritable:!0}]}return new Jt({keys:n,programId:this.programId,data:e})}}vr.programId=new q("11111111111111111111111111111111"),new q("BPFLoader2111111111111111111111111111111111");function $l(r){return r&&r.__esModule&&Object.prototype.hasOwnProperty.call(r,"default")?r.default:r}var Ml=Object.prototype.toString,jl=Object.keys||function(r){var t=[];for(var e in r)t.push(e);return t};function zr(r,t){var e,n,i,o,s,a,c;if(r===!0)return"true";if(r===!1)return"false";switch(typeof r){case"object":if(r===null)return null;if(r.toJSON&&typeof r.toJSON=="function")return zr(r.toJSON(),t);if(c=Ml.call(r),c==="[object Array]"){for(i="[",n=r.length-1,e=0;e<n;e++)i+=zr(r[e],!0)+",";return n>-1&&(i+=zr(r[e],!0)),i+"]"}else if(c==="[object Object]"){for(o=jl(r).sort(),n=o.length,i="",e=0;e<n;)s=o[e],a=zr(r[s],!1),a!==void 0&&(i&&(i+=","),i+=JSON.stringify(s)+":"+a),e++;return"{"+i+"}"}else return JSON.stringify(r);case"function":case"undefined":return t?null:void 0;case"string":return JSON.stringify(r);default:return isFinite(r)?r:null}}var Dl=function(r){var t=zr(r,!1);if(t!==void 0)return""+t},Os=$l(Dl);const Hr=32;function Si(r){let t=0;for(;r>1;)r/=2,t++;return t}function Vl(r){return r===0?1:(r--,r|=r>>1,r|=r>>2,r|=r>>4,r|=r>>8,r|=r>>16,r|=r>>32,r+1)}class Gl{constructor(t,e,n,i,o){this.slotsPerEpoch=void 0,this.leaderScheduleSlotOffset=void 0,this.warmup=void 0,this.firstNormalEpoch=void 0,this.firstNormalSlot=void 0,this.slotsPerEpoch=t,this.leaderScheduleSlotOffset=e,this.warmup=n,this.firstNormalEpoch=i,this.firstNormalSlot=o}getEpoch(t){return this.getEpochAndSlotIndex(t)[0]}getEpochAndSlotIndex(t){if(t<this.firstNormalSlot){const e=Si(Vl(t+Hr+1))-Si(Hr)-1,n=this.getSlotsInEpoch(e),i=t-(n-Hr);return[e,i]}else{const e=t-this.firstNormalSlot,n=Math.floor(e/this.slotsPerEpoch),i=this.firstNormalEpoch+n,o=e%this.slotsPerEpoch;return[i,o]}}getFirstSlotInEpoch(t){return t<=this.firstNormalEpoch?(Math.pow(2,t)-1)*Hr:(t-this.firstNormalEpoch)*this.slotsPerEpoch+this.firstNormalSlot}getLastSlotInEpoch(t){return this.getFirstSlotInEpoch(t)+this.getSlotsInEpoch(t)-1}getSlotsInEpoch(t){return t<this.firstNormalEpoch?Math.pow(2,t+Si(Hr)):this.slotsPerEpoch}}var Zl=globalThis.fetch;class Jl extends pl{constructor(t,e,n){const i=o=>{const s=dl(o,{autoconnect:!0,max_reconnects:5,reconnect:!0,reconnect_interval:1e3,...e});return"socket"in s?this.underlyingSocket=s.socket:this.underlyingSocket=s,s};super(i,t,e,n),this.underlyingSocket=void 0}call(...t){var n;const e=(n=this.underlyingSocket)==null?void 0:n.readyState;return e===1?super.call(...t):Promise.reject(new Error("Tried to call a JSON-RPC method `"+t[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+e+")"))}notify(...t){var n;const e=(n=this.underlyingSocket)==null?void 0:n.readyState;return e===1?super.notify(...t):Promise.reject(new Error("Tried to send a JSON-RPC notification `"+t[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+e+")"))}}function Yl(r,t){let e;try{e=r.layout.decode(t)}catch(n){throw new Error("invalid instruction; "+n)}if(e.typeIndex!==r.index)throw new Error(`invalid account data; account type mismatch ${e.typeIndex} != ${r.index}`);return e}const Ps=56;class Rs{constructor(t){this.key=void 0,this.state=void 0,this.key=t.key,this.state=t.state}isActive(){const t=BigInt("0xffffffffffffffff");return this.state.deactivationSlot===t}static deserialize(t){const e=Yl(Xl,t),n=t.length-Ps;kt(n>=0,"lookup table is invalid"),kt(n%32===0,"lookup table is invalid");const i=n/32,{addresses:o}=W([$t(it(),i,"addresses")]).decode(t.slice(Ps));return{deactivationSlot:e.deactivationSlot,lastExtendedSlot:e.lastExtendedSlot,lastExtendedSlotStartIndex:e.lastExtendedStartIndex,authority:e.authority.length!==0?new q(e.authority[0]):void 0,addresses:o.map(s=>new q(s))}}}const Xl={index:1,layout:W([j("typeIndex"),mr("deactivationSlot"),Ot("lastExtendedSlot"),nt("lastExtendedStartIndex"),nt(),$t(it(),Qe(nt(),-1),"authority")])},Ql=/^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;function th(r){const t=r.match(Ql);if(t==null)throw TypeError(`Failed to validate endpoint URL \`${r}\``);const[e,n,i,o]=t,s=r.startsWith("https:")?"wss:":"ws:",a=i==null?null:parseInt(i.slice(1),10),c=a==null?"":`:${a+1}`;return`${s}//${n}${c}${o}`}const wt=Rr(ci(q),L(),r=>new q(r)),Us=ui([L(),bt("base64")]),xi=Rr(ci(Y),Us,r=>Y.from(r[0],"base64")),eh=30*1e3;function rh(r){if(/^https?:/.test(r)===!1)throw new TypeError("Endpoint URL must start with `http:` or `https:`.");return r}function ft(r){let t,e;if(typeof r=="string")t=r;else if(r){const{commitment:n,...i}=r;t=n,e=i}return{commitment:t,config:e}}function Ns(r){return Mt([A({jsonrpc:bt("2.0"),id:L(),result:r}),A({jsonrpc:bt("2.0"),id:L(),error:A({code:fr(),message:L(),data:G(Uu())})})])}const nh=Ns(fr());function tt(r){return Rr(Ns(r),nh,t=>"error"in t?t:{...t,result:O(t.result,r)})}function xt(r){return tt(A({context:A({slot:b()}),value:r}))}function fn(r){return A({context:A({slot:b()}),value:r})}function Ei(r,t){return r===0?new An({header:t.header,staticAccountKeys:t.accountKeys.map(e=>new q(e)),recentBlockhash:t.recentBlockhash,compiledInstructions:t.instructions.map(e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:Ct.decode(e.data)})),addressTableLookups:t.addressTableLookups}):new $e(t)}const ih=A({foundation:b(),foundationTerm:b(),initial:b(),taper:b(),terminal:b()}),oh=tt(U(H(A({epoch:b(),effectiveSlot:b(),amount:b(),postBalance:b(),commission:G(H(b()))})))),sh=U(A({slot:b(),prioritizationFee:b()})),ah=A({total:b(),validator:b(),foundation:b(),epoch:b()}),ch=A({epoch:b(),slotIndex:b(),slotsInEpoch:b(),absoluteSlot:b(),blockHeight:G(b()),transactionCount:G(b())}),uh=A({slotsPerEpoch:b(),leaderScheduleSlotOffset:b(),warmup:ye(),firstNormalEpoch:b(),firstNormalSlot:b()}),lh=ss(L(),U(b())),rr=H(Mt([A({}),L()])),hh=A({err:rr}),dh=bt("receivedSignature"),fh=A({"solana-core":L(),"feature-set":G(b())}),ph=A({program:L(),programId:wt,parsed:fr()}),gh=A({programId:wt,accounts:U(wt),data:L()}),zs=xt(A({err:H(Mt([A({}),L()])),logs:H(U(L())),accounts:G(H(U(H(A({executable:ye(),owner:L(),lamports:b(),data:U(L()),rentEpoch:G(b())}))))),unitsConsumed:G(b()),returnData:G(H(A({programId:L(),data:ui([L(),bt("base64")])}))),innerInstructions:G(H(U(A({index:b(),instructions:U(Mt([ph,gh]))}))))})),yh=xt(A({byIdentity:ss(L(),U(b())),range:A({firstSlot:b(),lastSlot:b()})}));function mh(r,t,e,n,i,o){const s=e||Zl;let a;o!=null&&console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");let c;return n&&(c=async(u,l)=>{const h=await new Promise((y,f)=>{try{n(u,l,(p,d)=>y([p,d]))}catch(p){f(p)}});return await s(...h)}),new ll(async(u,l)=>{const h={method:"POST",body:u,agent:a,headers:Object.assign({"Content-Type":"application/json"},t||{},bd)};try{let y=5,f,p=500;for(;c?f=await c(r,h):f=await s(r,h),!(f.status!==429||i===!0||(y-=1,y===0));)console.error(`Server responded with ${f.status} ${f.statusText}.  Retrying after ${p}ms delay...`),await yr(p),p*=2;const d=await f.text();f.ok?l(null,d):l(new Error(`${f.status} ${f.statusText}: ${d}`))}catch(y){y instanceof Error&&l(y)}},{})}function bh(r){return(t,e)=>new Promise((n,i)=>{r.request(t,e,(o,s)=>{if(o){i(o);return}n(s)})})}function wh(r){return t=>new Promise((e,n)=>{t.length===0&&e([]);const i=t.map(o=>r.request(o.methodName,o.args));r.request(i,(o,s)=>{if(o){n(o);return}e(s)})})}const vh=tt(ih),Sh=tt(ah),xh=tt(sh),Eh=tt(ch),kh=tt(uh),Bh=tt(lh),Ah=tt(b()),Ih=xt(A({total:b(),circulating:b(),nonCirculating:b(),nonCirculatingAccounts:U(wt)})),ki=A({amount:L(),uiAmount:H(b()),decimals:b(),uiAmountString:G(L())}),_h=xt(U(A({address:wt,amount:L(),uiAmount:H(b()),decimals:b(),uiAmountString:G(L())}))),Lh=xt(U(A({pubkey:wt,account:A({executable:ye(),owner:wt,lamports:b(),data:xi,rentEpoch:b()})}))),Bi=A({program:L(),parsed:fr(),space:b()}),Ch=xt(U(A({pubkey:wt,account:A({executable:ye(),owner:wt,lamports:b(),data:Bi,rentEpoch:b()})}))),Th=xt(U(A({lamports:b(),address:wt}))),qr=A({executable:ye(),owner:wt,lamports:b(),data:xi,rentEpoch:b()}),Oh=A({pubkey:wt,account:qr}),Ph=Rr(Mt([ci(Y),Bi]),Mt([Us,Bi]),r=>Array.isArray(r)?O(r,xi):r),Ai=A({executable:ye(),owner:wt,lamports:b(),data:Ph,rentEpoch:b()}),Rh=A({pubkey:wt,account:Ai}),Uh=A({state:Mt([bt("active"),bt("inactive"),bt("activating"),bt("deactivating")]),active:b(),inactive:b()}),Nh=tt(U(A({signature:L(),slot:b(),err:rr,memo:H(L()),blockTime:G(H(b()))}))),zh=tt(U(A({signature:L(),slot:b(),err:rr,memo:H(L()),blockTime:G(H(b()))}))),Hh=A({subscription:b(),result:fn(qr)}),qh=A({pubkey:wt,account:qr}),Fh=A({subscription:b(),result:fn(qh)}),Kh=A({parent:b(),slot:b(),root:b()}),Wh=A({subscription:b(),result:Kh}),$h=Mt([A({type:Mt([bt("firstShredReceived"),bt("completed"),bt("optimisticConfirmation"),bt("root")]),slot:b(),timestamp:b()}),A({type:bt("createdBank"),parent:b(),slot:b(),timestamp:b()}),A({type:bt("frozen"),slot:b(),timestamp:b(),stats:A({numTransactionEntries:b(),numSuccessfulTransactions:b(),numFailedTransactions:b(),maxTransactionsPerEntry:b()})}),A({type:bt("dead"),slot:b(),timestamp:b(),err:L()})]),Mh=A({subscription:b(),result:$h}),jh=A({subscription:b(),result:fn(Mt([hh,dh]))}),Dh=A({subscription:b(),result:b()}),Vh=A({pubkey:L(),gossip:H(L()),tpu:H(L()),rpc:H(L()),version:H(L())}),Hs=A({votePubkey:L(),nodePubkey:L(),activatedStake:b(),epochVoteAccount:ye(),epochCredits:U(ui([b(),b(),b()])),commission:b(),lastVote:b(),rootSlot:H(b())}),Gh=tt(A({current:U(Hs),delinquent:U(Hs)})),Zh=Mt([bt("processed"),bt("confirmed"),bt("finalized")]),Jh=A({slot:b(),confirmations:H(b()),err:rr,confirmationStatus:G(Zh)}),Yh=xt(U(H(Jh))),Xh=tt(b()),qs=A({accountKey:wt,writableIndexes:U(b()),readonlyIndexes:U(b())}),Ii=A({signatures:U(L()),message:A({accountKeys:U(L()),header:A({numRequiredSignatures:b(),numReadonlySignedAccounts:b(),numReadonlyUnsignedAccounts:b()}),instructions:U(A({accounts:U(b()),data:L(),programIdIndex:b()})),recentBlockhash:L(),addressTableLookups:G(U(qs))})}),Fs=A({pubkey:wt,signer:ye(),writable:ye(),source:G(Mt([bt("transaction"),bt("lookupTable")]))}),Ks=A({accountKeys:U(Fs),signatures:U(L())}),Ws=A({parsed:fr(),program:L(),programId:wt}),$s=A({accounts:U(wt),data:L(),programId:wt}),Qh=Mt([$s,Ws]),td=Mt([A({parsed:fr(),program:L(),programId:L()}),A({accounts:U(L()),data:L(),programId:L()})]),Ms=Rr(Qh,td,r=>"accounts"in r?O(r,$s):O(r,Ws)),js=A({signatures:U(L()),message:A({accountKeys:U(Fs),instructions:U(Ms),recentBlockhash:L(),addressTableLookups:G(H(U(qs)))})}),pn=A({accountIndex:b(),mint:L(),owner:G(L()),uiTokenAmount:ki}),Ds=A({writable:U(wt),readonly:U(wt)}),gn=A({err:rr,fee:b(),innerInstructions:G(H(U(A({index:b(),instructions:U(A({accounts:U(b()),data:L(),programIdIndex:b()}))})))),preBalances:U(b()),postBalances:U(b()),logMessages:G(H(U(L()))),preTokenBalances:G(H(U(pn))),postTokenBalances:G(H(U(pn))),loadedAddresses:G(Ds),computeUnitsConsumed:G(b())}),_i=A({err:rr,fee:b(),innerInstructions:G(H(U(A({index:b(),instructions:U(Ms)})))),preBalances:U(b()),postBalances:U(b()),logMessages:G(H(U(L()))),preTokenBalances:G(H(U(pn))),postTokenBalances:G(H(U(pn))),loadedAddresses:G(Ds),computeUnitsConsumed:G(b())}),br=Mt([bt(0),bt("legacy")]),nr=A({pubkey:L(),lamports:b(),postBalance:H(b()),rewardType:H(L()),commission:G(H(b()))}),ed=tt(H(A({blockhash:L(),previousBlockhash:L(),parentSlot:b(),transactions:U(A({transaction:Ii,meta:H(gn),version:G(br)})),rewards:G(U(nr)),blockTime:H(b()),blockHeight:H(b())}))),rd=tt(H(A({blockhash:L(),previousBlockhash:L(),parentSlot:b(),rewards:G(U(nr)),blockTime:H(b()),blockHeight:H(b())}))),nd=tt(H(A({blockhash:L(),previousBlockhash:L(),parentSlot:b(),transactions:U(A({transaction:Ks,meta:H(gn),version:G(br)})),rewards:G(U(nr)),blockTime:H(b()),blockHeight:H(b())}))),id=tt(H(A({blockhash:L(),previousBlockhash:L(),parentSlot:b(),transactions:U(A({transaction:js,meta:H(_i),version:G(br)})),rewards:G(U(nr)),blockTime:H(b()),blockHeight:H(b())}))),od=tt(H(A({blockhash:L(),previousBlockhash:L(),parentSlot:b(),transactions:U(A({transaction:Ks,meta:H(_i),version:G(br)})),rewards:G(U(nr)),blockTime:H(b()),blockHeight:H(b())}))),sd=tt(H(A({blockhash:L(),previousBlockhash:L(),parentSlot:b(),rewards:G(U(nr)),blockTime:H(b()),blockHeight:H(b())}))),ad=tt(H(A({blockhash:L(),previousBlockhash:L(),parentSlot:b(),transactions:U(A({transaction:Ii,meta:H(gn)})),rewards:G(U(nr)),blockTime:H(b())}))),Vs=tt(H(A({blockhash:L(),previousBlockhash:L(),parentSlot:b(),signatures:U(L()),blockTime:H(b())}))),Li=tt(H(A({slot:b(),meta:H(gn),blockTime:G(H(b())),transaction:Ii,version:G(br)}))),yn=tt(H(A({slot:b(),transaction:js,meta:H(_i),blockTime:G(H(b())),version:G(br)}))),cd=xt(A({blockhash:L(),feeCalculator:A({lamportsPerSignature:b()})})),ud=xt(A({blockhash:L(),lastValidBlockHeight:b()})),ld=xt(ye()),hd=A({slot:b(),numTransactions:b(),numSlots:b(),samplePeriodSecs:b()}),dd=tt(U(hd)),fd=xt(H(A({feeCalculator:A({lamportsPerSignature:b()})}))),pd=tt(L()),gd=tt(L()),yd=A({err:rr,logs:U(L()),signature:L()}),md=A({result:fn(yd),subscription:b()}),bd={"solana-client":"js/0.0.0-development"};class wd{constructor(t,e){this._commitment=void 0,this._confirmTransactionInitialTimeout=void 0,this._rpcEndpoint=void 0,this._rpcWsEndpoint=void 0,this._rpcClient=void 0,this._rpcRequest=void 0,this._rpcBatchRequest=void 0,this._rpcWebSocket=void 0,this._rpcWebSocketConnected=!1,this._rpcWebSocketHeartbeat=null,this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketGeneration=0,this._disableBlockhashCaching=!1,this._pollingBlockhash=!1,this._blockhashInfo={latestBlockhash:null,lastFetch:0,transactionSignatures:[],simulatedSignatures:[]},this._nextClientSubscriptionId=0,this._subscriptionDisposeFunctionsByClientSubscriptionId={},this._subscriptionHashByClientSubscriptionId={},this._subscriptionStateChangeCallbacksByHash={},this._subscriptionCallbacksByServerSubscriptionId={},this._subscriptionsByHash={},this._subscriptionsAutoDisposedByRpc=new Set,this.getBlockHeight=(()=>{const u={};return async l=>{const{commitment:h,config:y}=ft(l),f=this._buildArgs([],h,void 0,y),p=Os(f);return u[p]=u[p]??(async()=>{try{const d=await this._rpcRequest("getBlockHeight",f),g=O(d,tt(b()));if("error"in g)throw new M(g.error,"failed to get block height information");return g.result}finally{delete u[p]}})(),await u[p]}})();let n,i,o,s,a,c;e&&typeof e=="string"?this._commitment=e:e&&(this._commitment=e.commitment,this._confirmTransactionInitialTimeout=e.confirmTransactionInitialTimeout,n=e.wsEndpoint,i=e.httpHeaders,o=e.fetch,s=e.fetchMiddleware,a=e.disableRetryOnRateLimit,c=e.httpAgent),this._rpcEndpoint=rh(t),this._rpcWsEndpoint=n||th(t),this._rpcClient=mh(t,i,o,s,a,c),this._rpcRequest=bh(this._rpcClient),this._rpcBatchRequest=wh(this._rpcClient),this._rpcWebSocket=new Jl(this._rpcWsEndpoint,{autoconnect:!1,max_reconnects:1/0}),this._rpcWebSocket.on("open",this._wsOnOpen.bind(this)),this._rpcWebSocket.on("error",this._wsOnError.bind(this)),this._rpcWebSocket.on("close",this._wsOnClose.bind(this)),this._rpcWebSocket.on("accountNotification",this._wsOnAccountNotification.bind(this)),this._rpcWebSocket.on("programNotification",this._wsOnProgramAccountNotification.bind(this)),this._rpcWebSocket.on("slotNotification",this._wsOnSlotNotification.bind(this)),this._rpcWebSocket.on("slotsUpdatesNotification",this._wsOnSlotUpdatesNotification.bind(this)),this._rpcWebSocket.on("signatureNotification",this._wsOnSignatureNotification.bind(this)),this._rpcWebSocket.on("rootNotification",this._wsOnRootNotification.bind(this)),this._rpcWebSocket.on("logsNotification",this._wsOnLogsNotification.bind(this))}get commitment(){return this._commitment}get rpcEndpoint(){return this._rpcEndpoint}async getBalanceAndContext(t,e){const{commitment:n,config:i}=ft(e),o=this._buildArgs([t.toBase58()],n,void 0,i),s=await this._rpcRequest("getBalance",o),a=O(s,xt(b()));if("error"in a)throw new M(a.error,`failed to get balance for ${t.toBase58()}`);return a.result}async getBalance(t,e){return await this.getBalanceAndContext(t,e).then(n=>n.value).catch(n=>{throw new Error("failed to get balance of account "+t.toBase58()+": "+n)})}async getBlockTime(t){const e=await this._rpcRequest("getBlockTime",[t]),n=O(e,tt(H(b())));if("error"in n)throw new M(n.error,`failed to get block time for slot ${t}`);return n.result}async getMinimumLedgerSlot(){const t=await this._rpcRequest("minimumLedgerSlot",[]),e=O(t,tt(b()));if("error"in e)throw new M(e.error,"failed to get minimum ledger slot");return e.result}async getFirstAvailableBlock(){const t=await this._rpcRequest("getFirstAvailableBlock",[]),e=O(t,Ah);if("error"in e)throw new M(e.error,"failed to get first available block");return e.result}async getSupply(t){let e={};typeof t=="string"?e={commitment:t}:t?e={...t,commitment:t&&t.commitment||this.commitment}:e={commitment:this.commitment};const n=await this._rpcRequest("getSupply",[e]),i=O(n,Ih);if("error"in i)throw new M(i.error,"failed to get supply");return i.result}async getTokenSupply(t,e){const n=this._buildArgs([t.toBase58()],e),i=await this._rpcRequest("getTokenSupply",n),o=O(i,xt(ki));if("error"in o)throw new M(o.error,"failed to get token supply");return o.result}async getTokenAccountBalance(t,e){const n=this._buildArgs([t.toBase58()],e),i=await this._rpcRequest("getTokenAccountBalance",n),o=O(i,xt(ki));if("error"in o)throw new M(o.error,"failed to get token account balance");return o.result}async getTokenAccountsByOwner(t,e,n){const{commitment:i,config:o}=ft(n);let s=[t.toBase58()];"mint"in e?s.push({mint:e.mint.toBase58()}):s.push({programId:e.programId.toBase58()});const a=this._buildArgs(s,i,"base64",o),c=await this._rpcRequest("getTokenAccountsByOwner",a),u=O(c,Lh);if("error"in u)throw new M(u.error,`failed to get token accounts owned by account ${t.toBase58()}`);return u.result}async getParsedTokenAccountsByOwner(t,e,n){let i=[t.toBase58()];"mint"in e?i.push({mint:e.mint.toBase58()}):i.push({programId:e.programId.toBase58()});const o=this._buildArgs(i,n,"jsonParsed"),s=await this._rpcRequest("getTokenAccountsByOwner",o),a=O(s,Ch);if("error"in a)throw new M(a.error,`failed to get token accounts owned by account ${t.toBase58()}`);return a.result}async getLargestAccounts(t){const e={...t,commitment:t&&t.commitment||this.commitment},n=e.filter||e.commitment?[e]:[],i=await this._rpcRequest("getLargestAccounts",n),o=O(i,Th);if("error"in o)throw new M(o.error,"failed to get largest accounts");return o.result}async getTokenLargestAccounts(t,e){const n=this._buildArgs([t.toBase58()],e),i=await this._rpcRequest("getTokenLargestAccounts",n),o=O(i,_h);if("error"in o)throw new M(o.error,"failed to get token largest accounts");return o.result}async getAccountInfoAndContext(t,e){const{commitment:n,config:i}=ft(e),o=this._buildArgs([t.toBase58()],n,"base64",i),s=await this._rpcRequest("getAccountInfo",o),a=O(s,xt(H(qr)));if("error"in a)throw new M(a.error,`failed to get info about account ${t.toBase58()}`);return a.result}async getParsedAccountInfo(t,e){const{commitment:n,config:i}=ft(e),o=this._buildArgs([t.toBase58()],n,"jsonParsed",i),s=await this._rpcRequest("getAccountInfo",o),a=O(s,xt(H(Ai)));if("error"in a)throw new M(a.error,`failed to get info about account ${t.toBase58()}`);return a.result}async getAccountInfo(t,e){try{return(await this.getAccountInfoAndContext(t,e)).value}catch(n){throw new Error("failed to get info about account "+t.toBase58()+": "+n)}}async getMultipleParsedAccounts(t,e){const{commitment:n,config:i}=ft(e),o=t.map(u=>u.toBase58()),s=this._buildArgs([o],n,"jsonParsed",i),a=await this._rpcRequest("getMultipleAccounts",s),c=O(a,xt(U(H(Ai))));if("error"in c)throw new M(c.error,`failed to get info for accounts ${o}`);return c.result}async getMultipleAccountsInfoAndContext(t,e){const{commitment:n,config:i}=ft(e),o=t.map(u=>u.toBase58()),s=this._buildArgs([o],n,"base64",i),a=await this._rpcRequest("getMultipleAccounts",s),c=O(a,xt(U(H(qr))));if("error"in c)throw new M(c.error,`failed to get info for accounts ${o}`);return c.result}async getMultipleAccountsInfo(t,e){return(await this.getMultipleAccountsInfoAndContext(t,e)).value}async getStakeActivation(t,e,n){const{commitment:i,config:o}=ft(e),s=this._buildArgs([t.toBase58()],i,void 0,{...o,epoch:n??(o==null?void 0:o.epoch)}),a=await this._rpcRequest("getStakeActivation",s),c=O(a,tt(Uh));if("error"in c)throw new M(c.error,`failed to get Stake Activation ${t.toBase58()}`);return c.result}async getProgramAccounts(t,e){const{commitment:n,config:i}=ft(e),{encoding:o,...s}=i||{},a=this._buildArgs([t.toBase58()],n,o||"base64",s),c=await this._rpcRequest("getProgramAccounts",a),u=U(Oh),l=s.withContext===!0?O(c,xt(u)):O(c,tt(u));if("error"in l)throw new M(l.error,`failed to get accounts owned by program ${t.toBase58()}`);return l.result}async getParsedProgramAccounts(t,e){const{commitment:n,config:i}=ft(e),o=this._buildArgs([t.toBase58()],n,"jsonParsed",i),s=await this._rpcRequest("getProgramAccounts",o),a=O(s,tt(U(Rh)));if("error"in a)throw new M(a.error,`failed to get accounts owned by program ${t.toBase58()}`);return a.result}async confirmTransaction(t,e){var o;let n;if(typeof t=="string")n=t;else{const s=t;if((o=s.abortSignal)!=null&&o.aborted)return Promise.reject(s.abortSignal.reason);n=s.signature}let i;try{i=Ct.decode(n)}catch{throw new Error("signature must be base58 encoded: "+n)}return kt(i.length===64,"signature has invalid length"),typeof t=="string"?await this.confirmTransactionUsingLegacyTimeoutStrategy({commitment:e||this.commitment,signature:n}):"lastValidBlockHeight"in t?await this.confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:e||this.commitment,strategy:t}):await this.confirmTransactionUsingDurableNonceStrategy({commitment:e||this.commitment,strategy:t})}getCancellationPromise(t){return new Promise((e,n)=>{t!=null&&(t.aborted?n(t.reason):t.addEventListener("abort",()=>{n(t.reason)}))})}getTransactionConfirmationPromise({commitment:t,signature:e}){let n,i,o=!1;const s=new Promise((a,c)=>{try{n=this.onSignature(e,(l,h)=>{n=void 0;const y={context:h,value:l};a({__type:Ue.PROCESSED,response:y})},t);const u=new Promise(l=>{n==null?l():i=this._onSubscriptionStateChange(n,h=>{h==="subscribed"&&l()})});(async()=>{if(await u,o)return;const l=await this.getSignatureStatus(e);if(o||l==null)return;const{context:h,value:y}=l;if(y!=null)if(y!=null&&y.err)c(y.err);else{switch(t){case"confirmed":case"single":case"singleGossip":{if(y.confirmationStatus==="processed")return;break}case"finalized":case"max":case"root":{if(y.confirmationStatus==="processed"||y.confirmationStatus==="confirmed")return;break}case"processed":case"recent":}o=!0,a({__type:Ue.PROCESSED,response:{context:h,value:y}})}})()}catch(u){c(u)}});return{abortConfirmation:()=>{i&&(i(),i=void 0),n!=null&&(this.removeSignatureListener(n),n=void 0)},confirmationPromise:s}}async confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:t,strategy:{abortSignal:e,lastValidBlockHeight:n,signature:i}}){let o=!1;const s=new Promise(h=>{const y=async()=>{try{return await this.getBlockHeight(t)}catch{return-1}};(async()=>{let f=await y();if(!o){for(;f<=n;)if(await yr(1e3),o||(f=await y(),o))return;h({__type:Ue.BLOCKHEIGHT_EXCEEDED})}})()}),{abortConfirmation:a,confirmationPromise:c}=this.getTransactionConfirmationPromise({commitment:t,signature:i}),u=this.getCancellationPromise(e);let l;try{const h=await Promise.race([u,c,s]);if(h.__type===Ue.PROCESSED)l=h.response;else throw new Bs(i)}finally{o=!0,a()}return l}async confirmTransactionUsingDurableNonceStrategy({commitment:t,strategy:{abortSignal:e,minContextSlot:n,nonceAccountPubkey:i,nonceValue:o,signature:s}}){let a=!1;const c=new Promise(f=>{let p=o,d=null;const g=async()=>{try{const{context:S,value:B}=await this.getNonceAndContext(i,{commitment:t,minContextSlot:n});return d=S.slot,B==null?void 0:B.nonce}catch{return p}};(async()=>{if(p=await g(),!a)for(;;){if(o!==p){f({__type:Ue.NONCE_INVALID,slotInWhichNonceDidAdvance:d});return}if(await yr(2e3),a||(p=await g(),a))return}})()}),{abortConfirmation:u,confirmationPromise:l}=this.getTransactionConfirmationPromise({commitment:t,signature:s}),h=this.getCancellationPromise(e);let y;try{const f=await Promise.race([h,l,c]);if(f.__type===Ue.PROCESSED)y=f.response;else{let p;for(;;){const d=await this.getSignatureStatus(s);if(d==null)break;if(d.context.slot<(f.slotInWhichNonceDidAdvance??n)){await yr(400);continue}p=d;break}if(p!=null&&p.value){const d=t||"finalized",{confirmationStatus:g}=p.value;switch(d){case"processed":case"recent":if(g!=="processed"&&g!=="confirmed"&&g!=="finalized")throw new Nr(s);break;case"confirmed":case"single":case"singleGossip":if(g!=="confirmed"&&g!=="finalized")throw new Nr(s);break;case"finalized":case"max":case"root":if(g!=="finalized")throw new Nr(s);break;default:}y={context:p.context,value:{err:p.value.err}}}else throw new Nr(s)}}finally{a=!0,u()}return y}async confirmTransactionUsingLegacyTimeoutStrategy({commitment:t,signature:e}){let n;const i=new Promise(c=>{let u=this._confirmTransactionInitialTimeout||6e4;switch(t){case"processed":case"recent":case"single":case"confirmed":case"singleGossip":{u=this._confirmTransactionInitialTimeout||3e4;break}}n=setTimeout(()=>c({__type:Ue.TIMED_OUT,timeoutMs:u}),u)}),{abortConfirmation:o,confirmationPromise:s}=this.getTransactionConfirmationPromise({commitment:t,signature:e});let a;try{const c=await Promise.race([s,i]);if(c.__type===Ue.PROCESSED)a=c.response;else throw new As(e,c.timeoutMs/1e3)}finally{clearTimeout(n),o()}return a}async getClusterNodes(){const t=await this._rpcRequest("getClusterNodes",[]),e=O(t,tt(U(Vh)));if("error"in e)throw new M(e.error,"failed to get cluster nodes");return e.result}async getVoteAccounts(t){const e=this._buildArgs([],t),n=await this._rpcRequest("getVoteAccounts",e),i=O(n,Gh);if("error"in i)throw new M(i.error,"failed to get vote accounts");return i.result}async getSlot(t){const{commitment:e,config:n}=ft(t),i=this._buildArgs([],e,void 0,n),o=await this._rpcRequest("getSlot",i),s=O(o,tt(b()));if("error"in s)throw new M(s.error,"failed to get slot");return s.result}async getSlotLeader(t){const{commitment:e,config:n}=ft(t),i=this._buildArgs([],e,void 0,n),o=await this._rpcRequest("getSlotLeader",i),s=O(o,tt(L()));if("error"in s)throw new M(s.error,"failed to get slot leader");return s.result}async getSlotLeaders(t,e){const n=[t,e],i=await this._rpcRequest("getSlotLeaders",n),o=O(i,tt(U(wt)));if("error"in o)throw new M(o.error,"failed to get slot leaders");return o.result}async getSignatureStatus(t,e){const{context:n,value:i}=await this.getSignatureStatuses([t],e);kt(i.length===1);const o=i[0];return{context:n,value:o}}async getSignatureStatuses(t,e){const n=[t];e&&n.push(e);const i=await this._rpcRequest("getSignatureStatuses",n),o=O(i,Yh);if("error"in o)throw new M(o.error,"failed to get signature status");return o.result}async getTransactionCount(t){const{commitment:e,config:n}=ft(t),i=this._buildArgs([],e,void 0,n),o=await this._rpcRequest("getTransactionCount",i),s=O(o,tt(b()));if("error"in s)throw new M(s.error,"failed to get transaction count");return s.result}async getTotalSupply(t){return(await this.getSupply({commitment:t,excludeNonCirculatingAccountsList:!0})).value.total}async getInflationGovernor(t){const e=this._buildArgs([],t),n=await this._rpcRequest("getInflationGovernor",e),i=O(n,vh);if("error"in i)throw new M(i.error,"failed to get inflation");return i.result}async getInflationReward(t,e,n){const{commitment:i,config:o}=ft(n),s=this._buildArgs([t.map(u=>u.toBase58())],i,void 0,{...o,epoch:e??(o==null?void 0:o.epoch)}),a=await this._rpcRequest("getInflationReward",s),c=O(a,oh);if("error"in c)throw new M(c.error,"failed to get inflation reward");return c.result}async getInflationRate(){const t=await this._rpcRequest("getInflationRate",[]),e=O(t,Sh);if("error"in e)throw new M(e.error,"failed to get inflation rate");return e.result}async getEpochInfo(t){const{commitment:e,config:n}=ft(t),i=this._buildArgs([],e,void 0,n),o=await this._rpcRequest("getEpochInfo",i),s=O(o,Eh);if("error"in s)throw new M(s.error,"failed to get epoch info");return s.result}async getEpochSchedule(){const t=await this._rpcRequest("getEpochSchedule",[]),e=O(t,kh);if("error"in e)throw new M(e.error,"failed to get epoch schedule");const n=e.result;return new Gl(n.slotsPerEpoch,n.leaderScheduleSlotOffset,n.warmup,n.firstNormalEpoch,n.firstNormalSlot)}async getLeaderSchedule(){const t=await this._rpcRequest("getLeaderSchedule",[]),e=O(t,Bh);if("error"in e)throw new M(e.error,"failed to get leader schedule");return e.result}async getMinimumBalanceForRentExemption(t,e){const n=this._buildArgs([t],e),i=await this._rpcRequest("getMinimumBalanceForRentExemption",n),o=O(i,Xh);return"error"in o?(console.warn("Unable to fetch minimum balance for rent exemption"),0):o.result}async getRecentBlockhashAndContext(t){const e=this._buildArgs([],t),n=await this._rpcRequest("getRecentBlockhash",e),i=O(n,cd);if("error"in i)throw new M(i.error,"failed to get recent blockhash");return i.result}async getRecentPerformanceSamples(t){const e=await this._rpcRequest("getRecentPerformanceSamples",t?[t]:[]),n=O(e,dd);if("error"in n)throw new M(n.error,"failed to get recent performance samples");return n.result}async getFeeCalculatorForBlockhash(t,e){const n=this._buildArgs([t],e),i=await this._rpcRequest("getFeeCalculatorForBlockhash",n),o=O(i,fd);if("error"in o)throw new M(o.error,"failed to get fee calculator");const{context:s,value:a}=o.result;return{context:s,value:a!==null?a.feeCalculator:null}}async getFeeForMessage(t,e){const n=Rt(t.serialize()).toString("base64"),i=this._buildArgs([n],e),o=await this._rpcRequest("getFeeForMessage",i),s=O(o,xt(H(b())));if("error"in s)throw new M(s.error,"failed to get fee for message");if(s.result===null)throw new Error("invalid blockhash");return s.result}async getRecentPrioritizationFees(t){var s;const e=(s=t==null?void 0:t.lockedWritableAccounts)==null?void 0:s.map(a=>a.toBase58()),n=e!=null&&e.length?[e]:[],i=await this._rpcRequest("getRecentPrioritizationFees",n),o=O(i,xh);if("error"in o)throw new M(o.error,"failed to get recent prioritization fees");return o.result}async getRecentBlockhash(t){try{return(await this.getRecentBlockhashAndContext(t)).value}catch(e){throw new Error("failed to get recent blockhash: "+e)}}async getLatestBlockhash(t){try{return(await this.getLatestBlockhashAndContext(t)).value}catch(e){throw new Error("failed to get recent blockhash: "+e)}}async getLatestBlockhashAndContext(t){const{commitment:e,config:n}=ft(t),i=this._buildArgs([],e,void 0,n),o=await this._rpcRequest("getLatestBlockhash",i),s=O(o,ud);if("error"in s)throw new M(s.error,"failed to get latest blockhash");return s.result}async isBlockhashValid(t,e){const{commitment:n,config:i}=ft(e),o=this._buildArgs([t],n,void 0,i),s=await this._rpcRequest("isBlockhashValid",o),a=O(s,ld);if("error"in a)throw new M(a.error,"failed to determine if the blockhash `"+t+"`is valid");return a.result}async getVersion(){const t=await this._rpcRequest("getVersion",[]),e=O(t,tt(fh));if("error"in e)throw new M(e.error,"failed to get version");return e.result}async getGenesisHash(){const t=await this._rpcRequest("getGenesisHash",[]),e=O(t,tt(L()));if("error"in e)throw new M(e.error,"failed to get genesis hash");return e.result}async getBlock(t,e){const{commitment:n,config:i}=ft(e),o=this._buildArgsAtLeastConfirmed([t],n,void 0,i),s=await this._rpcRequest("getBlock",o);try{switch(i==null?void 0:i.transactionDetails){case"accounts":{const a=O(s,nd);if("error"in a)throw a.error;return a.result}case"none":{const a=O(s,rd);if("error"in a)throw a.error;return a.result}default:{const a=O(s,ed);if("error"in a)throw a.error;const{result:c}=a;return c?{...c,transactions:c.transactions.map(({transaction:u,meta:l,version:h})=>({meta:l,transaction:{...u,message:Ei(h,u.message)},version:h}))}:null}}}catch(a){throw new M(a,"failed to get confirmed block")}}async getParsedBlock(t,e){const{commitment:n,config:i}=ft(e),o=this._buildArgsAtLeastConfirmed([t],n,"jsonParsed",i),s=await this._rpcRequest("getBlock",o);try{switch(i==null?void 0:i.transactionDetails){case"accounts":{const a=O(s,od);if("error"in a)throw a.error;return a.result}case"none":{const a=O(s,sd);if("error"in a)throw a.error;return a.result}default:{const a=O(s,id);if("error"in a)throw a.error;return a.result}}}catch(a){throw new M(a,"failed to get block")}}async getBlockProduction(t){let e,n;if(typeof t=="string")n=t;else if(t){const{commitment:a,...c}=t;n=a,e=c}const i=this._buildArgs([],n,"base64",e),o=await this._rpcRequest("getBlockProduction",i),s=O(o,yh);if("error"in s)throw new M(s.error,"failed to get block production information");return s.result}async getTransaction(t,e){const{commitment:n,config:i}=ft(e),o=this._buildArgsAtLeastConfirmed([t],n,void 0,i),s=await this._rpcRequest("getTransaction",o),a=O(s,Li);if("error"in a)throw new M(a.error,"failed to get transaction");const c=a.result;return c&&{...c,transaction:{...c.transaction,message:Ei(c.version,c.transaction.message)}}}async getParsedTransaction(t,e){const{commitment:n,config:i}=ft(e),o=this._buildArgsAtLeastConfirmed([t],n,"jsonParsed",i),s=await this._rpcRequest("getTransaction",o),a=O(s,yn);if("error"in a)throw new M(a.error,"failed to get transaction");return a.result}async getParsedTransactions(t,e){const{commitment:n,config:i}=ft(e),o=t.map(s=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([s],n,"jsonParsed",i)}));return(await this._rpcBatchRequest(o)).map(s=>{const a=O(s,yn);if("error"in a)throw new M(a.error,"failed to get transactions");return a.result})}async getTransactions(t,e){const{commitment:n,config:i}=ft(e),o=t.map(s=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([s],n,void 0,i)}));return(await this._rpcBatchRequest(o)).map(s=>{const a=O(s,Li);if("error"in a)throw new M(a.error,"failed to get transactions");const c=a.result;return c&&{...c,transaction:{...c.transaction,message:Ei(c.version,c.transaction.message)}}})}async getConfirmedBlock(t,e){const n=this._buildArgsAtLeastConfirmed([t],e),i=await this._rpcRequest("getConfirmedBlock",n),o=O(i,ad);if("error"in o)throw new M(o.error,"failed to get confirmed block");const s=o.result;if(!s)throw new Error("Confirmed block "+t+" not found");const a={...s,transactions:s.transactions.map(({transaction:c,meta:u})=>{const l=new $e(c.message);return{meta:u,transaction:{...c,message:l}}})};return{...a,transactions:a.transactions.map(({transaction:c,meta:u})=>({meta:u,transaction:le.populate(c.message,c.signatures)}))}}async getBlocks(t,e,n){const i=this._buildArgsAtLeastConfirmed(e!==void 0?[t,e]:[t],n),o=await this._rpcRequest("getBlocks",i),s=O(o,tt(U(b())));if("error"in s)throw new M(s.error,"failed to get blocks");return s.result}async getBlockSignatures(t,e){const n=this._buildArgsAtLeastConfirmed([t],e,void 0,{transactionDetails:"signatures",rewards:!1}),i=await this._rpcRequest("getBlock",n),o=O(i,Vs);if("error"in o)throw new M(o.error,"failed to get block");const s=o.result;if(!s)throw new Error("Block "+t+" not found");return s}async getConfirmedBlockSignatures(t,e){const n=this._buildArgsAtLeastConfirmed([t],e,void 0,{transactionDetails:"signatures",rewards:!1}),i=await this._rpcRequest("getConfirmedBlock",n),o=O(i,Vs);if("error"in o)throw new M(o.error,"failed to get confirmed block");const s=o.result;if(!s)throw new Error("Confirmed block "+t+" not found");return s}async getConfirmedTransaction(t,e){const n=this._buildArgsAtLeastConfirmed([t],e),i=await this._rpcRequest("getConfirmedTransaction",n),o=O(i,Li);if("error"in o)throw new M(o.error,"failed to get transaction");const s=o.result;if(!s)return s;const a=new $e(s.transaction.message),c=s.transaction.signatures;return{...s,transaction:le.populate(a,c)}}async getParsedConfirmedTransaction(t,e){const n=this._buildArgsAtLeastConfirmed([t],e,"jsonParsed"),i=await this._rpcRequest("getConfirmedTransaction",n),o=O(i,yn);if("error"in o)throw new M(o.error,"failed to get confirmed transaction");return o.result}async getParsedConfirmedTransactions(t,e){const n=t.map(i=>({methodName:"getConfirmedTransaction",args:this._buildArgsAtLeastConfirmed([i],e,"jsonParsed")}));return(await this._rpcBatchRequest(n)).map(i=>{const o=O(i,yn);if("error"in o)throw new M(o.error,"failed to get confirmed transactions");return o.result})}async getConfirmedSignaturesForAddress(t,e,n){let i={},o=await this.getFirstAvailableBlock();for(;!("until"in i)&&(e--,!(e<=0||e<o));)try{const a=await this.getConfirmedBlockSignatures(e,"finalized");a.signatures.length>0&&(i.until=a.signatures[a.signatures.length-1].toString())}catch(a){if(a instanceof Error&&a.message.includes("skipped"))continue;throw a}let s=await this.getSlot("finalized");for(;!("before"in i)&&(n++,!(n>s));)try{const a=await this.getConfirmedBlockSignatures(n);a.signatures.length>0&&(i.before=a.signatures[a.signatures.length-1].toString())}catch(a){if(a instanceof Error&&a.message.includes("skipped"))continue;throw a}return(await this.getConfirmedSignaturesForAddress2(t,i)).map(a=>a.signature)}async getConfirmedSignaturesForAddress2(t,e,n){const i=this._buildArgsAtLeastConfirmed([t.toBase58()],n,void 0,e),o=await this._rpcRequest("getConfirmedSignaturesForAddress2",i),s=O(o,Nh);if("error"in s)throw new M(s.error,"failed to get confirmed signatures for address");return s.result}async getSignaturesForAddress(t,e,n){const i=this._buildArgsAtLeastConfirmed([t.toBase58()],n,void 0,e),o=await this._rpcRequest("getSignaturesForAddress",i),s=O(o,zh);if("error"in s)throw new M(s.error,"failed to get signatures for address");return s.result}async getAddressLookupTable(t,e){const{context:n,value:i}=await this.getAccountInfoAndContext(t,e);let o=null;return i!==null&&(o=new Rs({key:t,state:Rs.deserialize(i.data)})),{context:n,value:o}}async getNonceAndContext(t,e){const{context:n,value:i}=await this.getAccountInfoAndContext(t,e);let o=null;return i!==null&&(o=eo.fromAccountData(i.data)),{context:n,value:o}}async getNonce(t,e){return await this.getNonceAndContext(t,e).then(n=>n.value).catch(n=>{throw new Error("failed to get nonce for account "+t.toBase58()+": "+n)})}async requestAirdrop(t,e){const n=await this._rpcRequest("requestAirdrop",[t.toBase58(),e]),i=O(n,pd);if("error"in i)throw new M(i.error,`airdrop to ${t.toBase58()} failed`);return i.result}async _blockhashWithExpiryBlockHeight(t){if(!t){for(;this._pollingBlockhash;)await yr(100);const e=Date.now()-this._blockhashInfo.lastFetch>=eh;if(this._blockhashInfo.latestBlockhash!==null&&!e)return this._blockhashInfo.latestBlockhash}return await this._pollNewBlockhash()}async _pollNewBlockhash(){this._pollingBlockhash=!0;try{const t=Date.now(),e=this._blockhashInfo.latestBlockhash,n=e?e.blockhash:null;for(let i=0;i<50;i++){const o=await this.getLatestBlockhash("finalized");if(n!==o.blockhash)return this._blockhashInfo={latestBlockhash:o,lastFetch:Date.now(),transactionSignatures:[],simulatedSignatures:[]},o;await yr(Hl/2)}throw new Error(`Unable to obtain a new blockhash after ${Date.now()-t}ms`)}finally{this._pollingBlockhash=!1}}async getStakeMinimumDelegation(t){const{commitment:e,config:n}=ft(t),i=this._buildArgs([],e,"base64",n),o=await this._rpcRequest("getStakeMinimumDelegation",i),s=O(o,xt(b()));if("error"in s)throw new M(s.error,"failed to get stake minimum delegation");return s.result}async simulateTransaction(t,e,n){if("message"in t){const f=t.serialize(),p=Y.from(f).toString("base64");if(Array.isArray(e)||n!==void 0)throw new Error("Invalid arguments");const d=e||{};d.encoding="base64","commitment"in d||(d.commitment=this.commitment),e&&typeof e=="object"&&"innerInstructions"in e&&(d.innerInstructions=e.innerInstructions);const g=[p,d],S=await this._rpcRequest("simulateTransaction",g),B=O(S,zs);if("error"in B)throw new Error("failed to simulate transaction: "+B.error.message);return B.result}let i;if(t instanceof le){let f=t;i=new le,i.feePayer=f.feePayer,i.instructions=t.instructions,i.nonceInfo=f.nonceInfo,i.signatures=f.signatures}else i=le.populate(t),i._message=i._json=void 0;if(e!==void 0&&!Array.isArray(e))throw new Error("Invalid arguments");const o=e;if(i.nonceInfo&&o)i.sign(...o);else{let f=this._disableBlockhashCaching;for(;;){const p=await this._blockhashWithExpiryBlockHeight(f);if(i.lastValidBlockHeight=p.lastValidBlockHeight,i.recentBlockhash=p.blockhash,!o)break;if(i.sign(...o),!i.signature)throw new Error("!signature");const d=i.signature.toString("base64");if(!this._blockhashInfo.simulatedSignatures.includes(d)&&!this._blockhashInfo.transactionSignatures.includes(d)){this._blockhashInfo.simulatedSignatures.push(d);break}else f=!0}}const s=i._compile(),a=s.serialize(),c=i._serialize(a).toString("base64"),u={encoding:"base64",commitment:this.commitment};if(n){const f=(Array.isArray(n)?n:s.nonProgramIds()).map(p=>p.toBase58());u.accounts={encoding:"base64",addresses:f}}o&&(u.sigVerify=!0),e&&typeof e=="object"&&"innerInstructions"in e&&(u.innerInstructions=e.innerInstructions);const l=[c,u],h=await this._rpcRequest("simulateTransaction",l),y=O(h,zs);if("error"in y){let f;if("data"in y.error&&(f=y.error.data.logs,f&&Array.isArray(f))){const p=`
    `,d=p+f.join(p);console.error(y.error.message,d)}throw new vi({action:"simulate",signature:"",transactionMessage:y.error.message,logs:f})}return y.result}async sendTransaction(t,e,n){if("version"in t){if(e&&Array.isArray(e))throw new Error("Invalid arguments");const s=t.serialize();return await this.sendRawTransaction(s,e)}if(e===void 0||!Array.isArray(e))throw new Error("Invalid arguments");const i=e;if(t.nonceInfo)t.sign(...i);else{let s=this._disableBlockhashCaching;for(;;){const a=await this._blockhashWithExpiryBlockHeight(s);if(t.lastValidBlockHeight=a.lastValidBlockHeight,t.recentBlockhash=a.blockhash,t.sign(...i),!t.signature)throw new Error("!signature");const c=t.signature.toString("base64");if(this._blockhashInfo.transactionSignatures.includes(c))s=!0;else{this._blockhashInfo.transactionSignatures.push(c);break}}}const o=t.serialize();return await this.sendRawTransaction(o,n)}async sendRawTransaction(t,e){const n=Rt(t).toString("base64");return await this.sendEncodedTransaction(n,e)}async sendEncodedTransaction(t,e){const n={encoding:"base64"},i=e&&e.skipPreflight,o=i===!0?"processed":e&&e.preflightCommitment||this.commitment;e&&e.maxRetries!=null&&(n.maxRetries=e.maxRetries),e&&e.minContextSlot!=null&&(n.minContextSlot=e.minContextSlot),i&&(n.skipPreflight=i),o&&(n.preflightCommitment=o);const s=[t,n],a=await this._rpcRequest("sendTransaction",s),c=O(a,gd);if("error"in c){let u;throw"data"in c.error&&(u=c.error.data.logs),new vi({action:i?"send":"simulate",signature:"",transactionMessage:c.error.message,logs:u})}return c.result}_wsOnOpen(){this._rpcWebSocketConnected=!0,this._rpcWebSocketHeartbeat=setInterval(()=>{(async()=>{try{await this._rpcWebSocket.notify("ping")}catch{}})()},5e3),this._updateSubscriptions()}_wsOnError(t){this._rpcWebSocketConnected=!1,console.error("ws error:",t.message)}_wsOnClose(t){if(this._rpcWebSocketConnected=!1,this._rpcWebSocketGeneration=(this._rpcWebSocketGeneration+1)%Number.MAX_SAFE_INTEGER,this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null),this._rpcWebSocketHeartbeat&&(clearInterval(this._rpcWebSocketHeartbeat),this._rpcWebSocketHeartbeat=null),t===1e3){this._updateSubscriptions();return}this._subscriptionCallbacksByServerSubscriptionId={},Object.entries(this._subscriptionsByHash).forEach(([e,n])=>{this._setSubscription(e,{...n,state:"pending"})})}_setSubscription(t,e){var i;const n=(i=this._subscriptionsByHash[t])==null?void 0:i.state;if(this._subscriptionsByHash[t]=e,n!==e.state){const o=this._subscriptionStateChangeCallbacksByHash[t];o&&o.forEach(s=>{try{s(e.state)}catch{}})}}_onSubscriptionStateChange(t,e){var o;const n=this._subscriptionHashByClientSubscriptionId[t];if(n==null)return()=>{};const i=(o=this._subscriptionStateChangeCallbacksByHash)[n]||(o[n]=new Set);return i.add(e),()=>{i.delete(e),i.size===0&&delete this._subscriptionStateChangeCallbacksByHash[n]}}async _updateSubscriptions(){if(Object.keys(this._subscriptionsByHash).length===0){this._rpcWebSocketConnected&&(this._rpcWebSocketConnected=!1,this._rpcWebSocketIdleTimeout=setTimeout(()=>{this._rpcWebSocketIdleTimeout=null;try{this._rpcWebSocket.close()}catch(n){n instanceof Error&&console.log(`Error when closing socket connection: ${n.message}`)}},500));return}if(this._rpcWebSocketIdleTimeout!==null&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketConnected=!0),!this._rpcWebSocketConnected){this._rpcWebSocket.connect();return}const t=this._rpcWebSocketGeneration,e=()=>t===this._rpcWebSocketGeneration;await Promise.all(Object.keys(this._subscriptionsByHash).map(async n=>{const i=this._subscriptionsByHash[n];if(i!==void 0)switch(i.state){case"pending":case"unsubscribed":if(i.callbacks.size===0){delete this._subscriptionsByHash[n],i.state==="unsubscribed"&&delete this._subscriptionCallbacksByServerSubscriptionId[i.serverSubscriptionId],await this._updateSubscriptions();return}await(async()=>{const{args:o,method:s}=i;try{this._setSubscription(n,{...i,state:"subscribing"});const a=await this._rpcWebSocket.call(s,o);this._setSubscription(n,{...i,serverSubscriptionId:a,state:"subscribed"}),this._subscriptionCallbacksByServerSubscriptionId[a]=i.callbacks,await this._updateSubscriptions()}catch(a){if(a instanceof Error&&console.error(`${s} error for argument`,o,a.message),!e())return;this._setSubscription(n,{...i,state:"pending"}),await this._updateSubscriptions()}})();break;case"subscribed":i.callbacks.size===0&&await(async()=>{const{serverSubscriptionId:o,unsubscribeMethod:s}=i;if(this._subscriptionsAutoDisposedByRpc.has(o))this._subscriptionsAutoDisposedByRpc.delete(o);else{this._setSubscription(n,{...i,state:"unsubscribing"}),this._setSubscription(n,{...i,state:"unsubscribing"});try{await this._rpcWebSocket.call(s,[o])}catch(a){if(a instanceof Error&&console.error(`${s} error:`,a.message),!e())return;this._setSubscription(n,{...i,state:"subscribed"}),await this._updateSubscriptions();return}}this._setSubscription(n,{...i,state:"unsubscribed"}),await this._updateSubscriptions()})();break}}))}_handleServerNotification(t,e){const n=this._subscriptionCallbacksByServerSubscriptionId[t];n!==void 0&&n.forEach(i=>{try{i(...e)}catch(o){console.error(o)}})}_wsOnAccountNotification(t){const{result:e,subscription:n}=O(t,Hh);this._handleServerNotification(n,[e.value,e.context])}_makeSubscription(t,e){const n=this._nextClientSubscriptionId++,i=Os([t.method,e]),o=this._subscriptionsByHash[i];return o===void 0?this._subscriptionsByHash[i]={...t,args:e,callbacks:new Set([t.callback]),state:"pending"}:o.callbacks.add(t.callback),this._subscriptionHashByClientSubscriptionId[n]=i,this._subscriptionDisposeFunctionsByClientSubscriptionId[n]=async()=>{delete this._subscriptionDisposeFunctionsByClientSubscriptionId[n],delete this._subscriptionHashByClientSubscriptionId[n];const s=this._subscriptionsByHash[i];kt(s!==void 0,`Could not find a \`Subscription\` when tearing down client subscription #${n}`),s.callbacks.delete(t.callback),await this._updateSubscriptions()},this._updateSubscriptions(),n}onAccountChange(t,e,n){const{commitment:i,config:o}=ft(n),s=this._buildArgs([t.toBase58()],i||this._commitment||"finalized","base64",o);return this._makeSubscription({callback:e,method:"accountSubscribe",unsubscribeMethod:"accountUnsubscribe"},s)}async removeAccountChangeListener(t){await this._unsubscribeClientSubscription(t,"account change")}_wsOnProgramAccountNotification(t){const{result:e,subscription:n}=O(t,Fh);this._handleServerNotification(n,[{accountId:e.value.pubkey,accountInfo:e.value.account},e.context])}onProgramAccountChange(t,e,n,i){const{commitment:o,config:s}=ft(n),a=this._buildArgs([t.toBase58()],o||this._commitment||"finalized","base64",s||(i?{filters:i}:void 0));return this._makeSubscription({callback:e,method:"programSubscribe",unsubscribeMethod:"programUnsubscribe"},a)}async removeProgramAccountChangeListener(t){await this._unsubscribeClientSubscription(t,"program account change")}onLogs(t,e,n){const i=this._buildArgs([typeof t=="object"?{mentions:[t.toString()]}:t],n||this._commitment||"finalized");return this._makeSubscription({callback:e,method:"logsSubscribe",unsubscribeMethod:"logsUnsubscribe"},i)}async removeOnLogsListener(t){await this._unsubscribeClientSubscription(t,"logs")}_wsOnLogsNotification(t){const{result:e,subscription:n}=O(t,md);this._handleServerNotification(n,[e.value,e.context])}_wsOnSlotNotification(t){const{result:e,subscription:n}=O(t,Wh);this._handleServerNotification(n,[e])}onSlotChange(t){return this._makeSubscription({callback:t,method:"slotSubscribe",unsubscribeMethod:"slotUnsubscribe"},[])}async removeSlotChangeListener(t){await this._unsubscribeClientSubscription(t,"slot change")}_wsOnSlotUpdatesNotification(t){const{result:e,subscription:n}=O(t,Mh);this._handleServerNotification(n,[e])}onSlotUpdate(t){return this._makeSubscription({callback:t,method:"slotsUpdatesSubscribe",unsubscribeMethod:"slotsUpdatesUnsubscribe"},[])}async removeSlotUpdateListener(t){await this._unsubscribeClientSubscription(t,"slot update")}async _unsubscribeClientSubscription(t,e){const n=this._subscriptionDisposeFunctionsByClientSubscriptionId[t];n?await n():console.warn(`Ignored unsubscribe request because an active subscription with id \`${t}\` for '${e}' events could not be found.`)}_buildArgs(t,e,n,i){const o=e||this._commitment;if(o||n||i){let s={};n&&(s.encoding=n),o&&(s.commitment=o),i&&(s=Object.assign(s,i)),t.push(s)}return t}_buildArgsAtLeastConfirmed(t,e,n,i){const o=e||this._commitment;if(o&&!["confirmed","finalized"].includes(o))throw new Error("Using Connection with default commitment: `"+this._commitment+"`, but method requires at least `confirmed`");return this._buildArgs(t,e,n,i)}_wsOnSignatureNotification(t){const{result:e,subscription:n}=O(t,jh);e.value!=="receivedSignature"&&this._subscriptionsAutoDisposedByRpc.add(n),this._handleServerNotification(n,e.value==="receivedSignature"?[{type:"received"},e.context]:[{type:"status",result:e.value},e.context])}onSignature(t,e,n){const i=this._buildArgs([t],n||this._commitment||"finalized"),o=this._makeSubscription({callback:(s,a)=>{if(s.type==="status"){e(s.result,a);try{this.removeSignatureListener(o)}catch{}}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},i);return o}onSignatureWithOptions(t,e,n){const{commitment:i,...o}={...n,commitment:n&&n.commitment||this._commitment||"finalized"},s=this._buildArgs([t],i,void 0,o),a=this._makeSubscription({callback:(c,u)=>{e(c,u);try{this.removeSignatureListener(a)}catch{}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},s);return a}async removeSignatureListener(t){await this._unsubscribeClientSubscription(t,"signature result")}_wsOnRootNotification(t){const{result:e,subscription:n}=O(t,Dh);this._handleServerNotification(n,[e])}onRootChange(t){return this._makeSubscription({callback:t,method:"rootSubscribe",unsubscribeMethod:"rootUnsubscribe"},[])}async removeRootChangeListener(t){await this._unsubscribeClientSubscription(t,"root change")}}class $r{constructor(t){this._keypair=void 0,this._keypair=t??ws()}static generate(){return new $r(ws())}static fromSecretKey(t,e){if(t.byteLength!==64)throw new Error("bad secret key size");const n=t.slice(32,64);if(!e||!e.skipValidation){const i=t.slice(0,32),o=bi(i);for(let s=0;s<32;s++)if(n[s]!==o[s])throw new Error("provided secretKey is invalid")}return new $r({publicKey:n,secretKey:t})}static fromSeed(t){const e=bi(t),n=new Uint8Array(64);return n.set(t),n.set(e,32),new $r({publicKey:e,secretKey:n})}get publicKey(){return new q(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}}Object.freeze({CreateLookupTable:{index:0,layout:W([j("instruction"),mr("recentSlot"),nt("bumpSeed")])},FreezeLookupTable:{index:1,layout:W([j("instruction")])},ExtendLookupTable:{index:2,layout:W([j("instruction"),mr(),$t(it(),Qe(j(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:W([j("instruction")])},CloseLookupTable:{index:4,layout:W([j("instruction")])}}),new q("AddressLookupTab1e1111111111111111111111111"),Object.freeze({RequestUnits:{index:0,layout:W([nt("instruction"),j("units"),j("additionalFee")])},RequestHeapFrame:{index:1,layout:W([nt("instruction"),j("bytes")])},SetComputeUnitLimit:{index:2,layout:W([nt("instruction"),j("units")])},SetComputeUnitPrice:{index:3,layout:W([nt("instruction"),mr("microLamports")])}}),new q("ComputeBudget111111111111111111111111111111"),W([nt("numSignatures"),nt("padding"),Qt("signatureOffset"),Qt("signatureInstructionIndex"),Qt("publicKeyOffset"),Qt("publicKeyInstructionIndex"),Qt("messageDataOffset"),Qt("messageDataSize"),Qt("messageInstructionIndex")]),new q("Ed25519SigVerify111111111111111111111111111"),mi.utils.isValidPrivateKey,mi.getPublicKey,W([nt("numSignatures"),Qt("signatureOffset"),nt("signatureInstructionIndex"),Qt("ethAddressOffset"),nt("ethAddressInstructionIndex"),Qt("messageDataOffset"),Qt("messageDataSize"),nt("messageInstructionIndex"),gt(20,"ethAddress"),gt(64,"signature"),nt("recoveryId")]),new q("KeccakSecp256k11111111111111111111111111111");var Gs;new q("StakeConfig11111111111111111111111111111111");class Zs{constructor(t,e,n){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=t,this.epoch=e,this.custodian=n}}Gs=Zs,Zs.default=new Gs(0,0,q.default),Object.freeze({Initialize:{index:0,layout:W([j("instruction"),Cl(),Tl()])},Authorize:{index:1,layout:W([j("instruction"),it("newAuthorized"),j("stakeAuthorizationType")])},Delegate:{index:2,layout:W([j("instruction")])},Split:{index:3,layout:W([j("instruction"),Zt("lamports")])},Withdraw:{index:4,layout:W([j("instruction"),Zt("lamports")])},Deactivate:{index:5,layout:W([j("instruction")])},Merge:{index:7,layout:W([j("instruction")])},AuthorizeWithSeed:{index:8,layout:W([j("instruction"),it("newAuthorized"),j("stakeAuthorizationType"),gr("authoritySeed"),it("authorityOwner")])}}),new q("Stake11111111111111111111111111111111111111"),Object.freeze({InitializeAccount:{index:0,layout:W([j("instruction"),Ol()])},Authorize:{index:1,layout:W([j("instruction"),it("newAuthorized"),j("voteAuthorizationType")])},Withdraw:{index:3,layout:W([j("instruction"),Zt("lamports")])},UpdateValidatorIdentity:{index:4,layout:W([j("instruction")])},AuthorizeWithSeed:{index:10,layout:W([j("instruction"),Pl()])}}),new q("Vote111111111111111111111111111111111111111"),new q("Va1idator1nfo111111111111111111111111111111"),A({name:L(),website:G(L()),details:G(L()),iconUrl:G(L()),keybaseUsername:G(L())}),new q("Vote111111111111111111111111111111111111111"),W([it("nodePubkey"),it("authorizedWithdrawer"),nt("commission"),Ot(),$t(W([Ot("slot"),j("confirmationCount")]),Qe(j(),-8),"votes"),nt("rootSlotValid"),Ot("rootSlot"),Ot(),$t(W([Ot("epoch"),it("authorizedVoter")]),Qe(j(),-8),"authorizedVoters"),W([$t(W([it("authorizedPubkey"),Ot("epochOfLastAuthorizedSwitch"),Ot("targetEpoch")]),32,"buf"),Ot("idx"),nt("isEmpty")],"priorVoters"),Ot(),$t(W([Ot("epoch"),Ot("credits"),Ot("prevCredits")]),Qe(j(),-8),"epochCredits"),W([Ot("slot"),Ot("timestamp")],"lastTimestamp")]);const Ee=new q("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");new q("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb");const Ci=new q("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");new q("So11111111111111111111111111111111111111112"),new q("9pan9bMn5HatX4EJdBwg9VgCa7Uz5HL8N1m5D3NdXejP");const Ti=r=>{const t=r.decode.bind(r),e=r.encode.bind(r);return{decode:t,encode:e}},vd=r=>t=>{const e=gt(r,t),{encode:n,decode:i}=Ti(e),o=e;return o.decode=(s,a)=>{const c=i(s,a);return rs(yt.from(c))},o.encode=(s,a,c)=>{const u=ns(s,r);return n(u,a,c)},o},Fr=vd(8),Js=r=>{const t=nt(r),{encode:e,decode:n}=Ti(t),i=t;return i.decode=(o,s)=>!!n(o,s),i.encode=(o,s,a)=>{const c=Number(o);return e(c,s,a)},i},Ut=r=>{const t=gt(32,r),{encode:e,decode:n}=Ti(t),i=t;return i.decode=(o,s)=>{const a=n(o,s);return new q(a)},i.encode=(o,s,a)=>{const c=o.toBuffer();return e(c,s,a)},i};class wr extends Error{constructor(t){super(t)}}class Ys extends wr{constructor(){super(...arguments),this.name="TokenAccountNotFoundError"}}class Sd extends wr{constructor(){super(...arguments),this.name="TokenInvalidAccountError"}}class Xs extends wr{constructor(){super(...arguments),this.name="TokenInvalidAccountOwnerError"}}class Kr extends wr{constructor(){super(...arguments),this.name="TokenInvalidAccountSizeError"}}class xd extends wr{constructor(){super(...arguments),this.name="TokenInvalidMintError"}}class Ed extends wr{constructor(){super(...arguments),this.name="TokenOwnerOffCurveError"}}var Oi;(function(r){r[r.InitializeMint=0]="InitializeMint",r[r.InitializeAccount=1]="InitializeAccount",r[r.InitializeMultisig=2]="InitializeMultisig",r[r.Transfer=3]="Transfer",r[r.Approve=4]="Approve",r[r.Revoke=5]="Revoke",r[r.SetAuthority=6]="SetAuthority",r[r.MintTo=7]="MintTo",r[r.Burn=8]="Burn",r[r.CloseAccount=9]="CloseAccount",r[r.FreezeAccount=10]="FreezeAccount",r[r.ThawAccount=11]="ThawAccount",r[r.TransferChecked=12]="TransferChecked",r[r.ApproveChecked=13]="ApproveChecked",r[r.MintToChecked=14]="MintToChecked",r[r.BurnChecked=15]="BurnChecked",r[r.InitializeAccount2=16]="InitializeAccount2",r[r.SyncNative=17]="SyncNative",r[r.InitializeAccount3=18]="InitializeAccount3",r[r.InitializeMultisig2=19]="InitializeMultisig2",r[r.InitializeMint2=20]="InitializeMint2",r[r.GetAccountDataSize=21]="GetAccountDataSize",r[r.InitializeImmutableOwner=22]="InitializeImmutableOwner",r[r.AmountToUiAmount=23]="AmountToUiAmount",r[r.UiAmountToAmount=24]="UiAmountToAmount",r[r.InitializeMintCloseAuthority=25]="InitializeMintCloseAuthority",r[r.TransferFeeExtension=26]="TransferFeeExtension",r[r.ConfidentialTransferExtension=27]="ConfidentialTransferExtension",r[r.DefaultAccountStateExtension=28]="DefaultAccountStateExtension",r[r.Reallocate=29]="Reallocate",r[r.MemoTransferExtension=30]="MemoTransferExtension",r[r.CreateNativeMint=31]="CreateNativeMint",r[r.InitializeNonTransferableMint=32]="InitializeNonTransferableMint",r[r.InterestBearingMintExtension=33]="InterestBearingMintExtension",r[r.CpiGuardExtension=34]="CpiGuardExtension",r[r.InitializePermanentDelegate=35]="InitializePermanentDelegate",r[r.TransferHookExtension=36]="TransferHookExtension",r[r.MetadataPointerExtension=39]="MetadataPointerExtension",r[r.GroupPointerExtension=40]="GroupPointerExtension",r[r.GroupMemberPointerExtension=41]="GroupMemberPointerExtension"})(Oi||(Oi={}));function kd(r,t,e){if(e.length){r.push({pubkey:t,isSigner:!1,isWritable:!1});for(const n of e)r.push({pubkey:n instanceof q?n:n.publicKey,isSigner:!0,isWritable:!1})}else r.push({pubkey:t,isSigner:!0,isWritable:!1});return r}var mn;(function(r){r[r.Uninitialized=0]="Uninitialized",r[r.Mint=1]="Mint",r[r.Account=2]="Account"})(mn||(mn={}));const Qs=1,Bd=W([nt("m"),nt("n"),Js("isInitialized"),Ut("signer1"),Ut("signer2"),Ut("signer3"),Ut("signer4"),Ut("signer5"),Ut("signer6"),Ut("signer7"),Ut("signer8"),Ut("signer9"),Ut("signer10"),Ut("signer11")]),ta=Bd.span;var bn;(function(r){r[r.Uninitialized=0]="Uninitialized",r[r.Initialized=1]="Initialized",r[r.Frozen=2]="Frozen"})(bn||(bn={}));const Pi=W([Ut("mint"),Ut("owner"),Fr("amount"),j("delegateOption"),Ut("delegate"),nt("state"),j("isNativeOption"),Fr("isNative"),Fr("delegatedAmount"),j("closeAuthorityOption"),Ut("closeAuthority")]),Ne=Pi.span;async function Ad(r,t,e,n=Ee){const i=await r.getAccountInfo(t,e);return Id(t,i,n)}function Id(r,t,e=Ee){if(!t)throw new Ys;if(!t.owner.equals(e))throw new Xs;if(t.data.length<Ne)throw new Kr;const n=Pi.decode(t.data.slice(0,Ne));let i=yt.alloc(0);if(t.data.length>Ne){if(t.data.length===ta)throw new Kr;if(t.data[Ne]!=mn.Account)throw new Sd;i=t.data.slice(Ne+Qs)}return{address:r,mint:n.mint,owner:n.owner,amount:n.amount,delegate:n.delegateOption?n.delegate:null,delegatedAmount:n.delegatedAmount,isInitialized:n.state!==bn.Uninitialized,isFrozen:n.state===bn.Frozen,isNative:!!n.isNativeOption,rentExemptReserve:n.isNativeOption?n.isNative:null,closeAuthority:n.closeAuthorityOption?n.closeAuthority:null,tlvData:i}}const ea=W([j("mintAuthorityOption"),Ut("mintAuthority"),Fr("supply"),nt("decimals"),Js("isInitialized"),j("freezeAuthorityOption"),Ut("freezeAuthority")]),Ri=ea.span;async function _d(r,t,e,n=Ee){const i=await r.getAccountInfo(t,e);return Ld(t,i,n)}function Ld(r,t,e=Ee){if(!t)throw new Ys;if(!t.owner.equals(e))throw new Xs;if(t.data.length<Ri)throw new Kr;const n=ea.decode(t.data.slice(0,Ri));let i=yt.alloc(0);if(t.data.length>Ri){if(t.data.length<=Ne)throw new Kr;if(t.data.length===ta)throw new Kr;if(t.data[Ne]!=mn.Mint)throw new xd;i=t.data.slice(Ne+Qs)}return{address:r,mintAuthority:n.mintAuthorityOption?n.mintAuthority:null,supply:n.supply,decimals:n.decimals,isInitialized:n.isInitialized,freezeAuthority:n.freezeAuthorityOption?n.freezeAuthority:null,tlvData:i}}async function ra(r,t,e=!1,n=Ee,i=Ci){if(!e&&!q.isOnCurve(t.toBuffer()))throw new Ed;const[o]=await q.findProgramAddress([t.toBuffer(),n.toBuffer(),r.toBuffer()],i);return o}const na=W([nt("instruction"),Fr("amount"),nt("decimals")]);function Cd(r,t,e,n,i,o,s=[],a=Ee){const c=kd([{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!1},{pubkey:e,isSigner:!1,isWritable:!0}],n,s),u=yt.alloc(na.span);return na.encode({instruction:Oi.TransferChecked,amount:BigInt(i),decimals:o},u),new Jt({keys:c,programId:a,data:u})}function Td(r,t,e,n,i=Ee,o=Ci){return Od(r,t,e,n,yt.alloc(0),i,o)}function Od(r,t,e,n,i,o=Ee,s=Ci){const a=[{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:vr.programId,isSigner:!1,isWritable:!1},{pubkey:o,isSigner:!1,isWritable:!1}];return new Jt({keys:a,programId:s,data:i})}function ia(r){if(!Number.isSafeInteger(r)||r<0)throw new Error(`positive integer expected, not ${r}`)}function Pd(r){return r instanceof Uint8Array||r!=null&&typeof r=="object"&&r.constructor.name==="Uint8Array"}function ze(r,...t){if(!Pd(r))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(r.length))throw new Error(`Uint8Array expected of length ${t}, not of length=${r.length}`)}function Rd(r){if(typeof r!="function"||typeof r.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");ia(r.outputLen),ia(r.blockLen)}function wn(r,t=!0){if(r.destroyed)throw new Error("Hash instance has been destroyed");if(t&&r.finished)throw new Error("Hash#digest() has already been called")}function Ud(r,t){ze(r);const e=t.outputLen;if(r.length<e)throw new Error(`digestInto() expects output buffer of length at least ${e}`)}var Ui=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;function oa(r){ze(r);let t="";for(let e=0;e<r.length;e++)t+=Hd[r[e]];return t}function sa(r){if(r>=ke._0&&r<=ke._9)return r-ke._0;if(r>=ke._A&&r<=ke._F)return r-(ke._A-10);if(r>=ke._a&&r<=ke._f)return r-(ke._a-10)}function Nd(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);const t=r.length,e=t/2;if(t%2)throw new Error("padded hex string expected, got unpadded hex of length "+t);const n=new Uint8Array(e);for(let i=0,o=0;i<e;i++,o+=2){const s=sa(r.charCodeAt(o)),a=sa(r.charCodeAt(o+1));if(s===void 0||a===void 0){const c=r[o]+r[o+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+o)}n[i]=s*16+a}return n}function aa(r){if(typeof r!="string")throw new Error(`utf8ToBytes expected string, got ${typeof r}`);return new Uint8Array(new TextEncoder().encode(r))}function Ni(r){return typeof r=="string"&&(r=aa(r)),ze(r),r}function ca(...r){let t=0;for(let n=0;n<r.length;n++){const i=r[n];ze(i),t+=i.length}const e=new Uint8Array(t);for(let n=0,i=0;n<r.length;n++){const o=r[n];e.set(o,i),i+=o.length}return e}function zi(r){const t=n=>r().update(Ni(n)).digest(),e=r();return t.outputLen=e.outputLen,t.blockLen=e.blockLen,t.create=()=>r(),t}function zd(r=32){if(Ui&&typeof Ui.getRandomValues=="function")return Ui.getRandomValues(new Uint8Array(r));throw new Error("crypto.getRandomValues must be defined")}/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */var Wr=r=>new DataView(r.buffer,r.byteOffset,r.byteLength),me=(r,t)=>r<<32-t|r>>>t,vn=(r,t)=>r<<t|r>>>32-t>>>0;new Uint8Array(new Uint32Array([287454020]).buffer)[0];var Hd=Array.from({length:256},(r,t)=>t.toString(16).padStart(2,"0")),ke={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};class ua{clone(){return this._cloneInto()}}function qd(r,t,e,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(t,e,n);const i=BigInt(32),o=BigInt(4294967295),s=Number(e>>i&o),a=Number(e&o),c=n?4:0,u=n?0:4;r.setUint32(t+c,s,n),r.setUint32(t+u,a,n)}var Fd=(r,t,e)=>r&t^~r&e,Kd=(r,t,e)=>r&t^r&e^t&e;class Hi extends ua{constructor(t,e,n,i){super(),this.blockLen=t,this.outputLen=e,this.padOffset=n,this.isLE=i,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=Wr(this.buffer)}update(t){wn(this);const{view:e,buffer:n,blockLen:i}=this;t=Ni(t);const o=t.length;for(let s=0;s<o;){const a=Math.min(i-this.pos,o-s);if(a===i){const c=Wr(t);for(;i<=o-s;s+=i)this.process(c,s);continue}n.set(t.subarray(s,s+a),this.pos),this.pos+=a,s+=a,this.pos===i&&(this.process(e,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){wn(this),Ud(t,this),this.finished=!0;const{buffer:e,view:n,blockLen:i,isLE:o}=this;let{pos:s}=this;e[s++]=128,this.buffer.subarray(s).fill(0),this.padOffset>i-s&&(this.process(n,0),s=0);for(let h=s;h<i;h++)e[h]=0;qd(n,i-8,BigInt(this.length*8),o),this.process(n,0);const a=Wr(t),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const u=c/4,l=this.get();if(u>l.length)throw new Error("_sha2: outputLen bigger than state");for(let h=0;h<u;h++)a.setUint32(4*h,l[h],o)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const n=t.slice(0,e);return this.destroy(),n}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:n,length:i,finished:o,destroyed:s,pos:a}=this;return t.length=i,t.pos=a,t.finished=o,t.destroyed=s,i%e&&t.buffer.set(n),t}}function la(r,t=!1){return t?{h:Number(r&Sn),l:Number(r>>qi&Sn)}:{h:Number(r>>qi&Sn)|0,l:Number(r&Sn)|0}}function Wd(r,t=!1){let e=new Uint32Array(r.length),n=new Uint32Array(r.length);for(let i=0;i<r.length;i++){const{h:o,l:s}=la(r[i],t);[e[i],n[i]]=[o,s]}return[e,n]}function $d(r,t,e,n){const i=(t>>>0)+(n>>>0);return{h:r+e+(i/4294967296|0)|0,l:i|0}}var Sn=BigInt(4294967295),qi=BigInt(32),Md=(r,t)=>BigInt(r>>>0)<<qi|BigInt(t>>>0),jd=(r,t,e)=>r>>>e,Dd=(r,t,e)=>r<<32-e|t>>>e,Vd=(r,t,e)=>r>>>e|t<<32-e,Gd=(r,t,e)=>r<<32-e|t>>>e,Zd=(r,t,e)=>r<<64-e|t>>>e-32,Jd=(r,t,e)=>r>>>e-32|t<<64-e,Yd=(r,t)=>t,Xd=(r,t)=>r,Qd=(r,t,e)=>r<<e|t>>>32-e,tf=(r,t,e)=>t<<e|r>>>32-e,ef=(r,t,e)=>t<<e-32|r>>>64-e,rf=(r,t,e)=>r<<e-32|t>>>64-e,nf=(r,t,e)=>(r>>>0)+(t>>>0)+(e>>>0),of=(r,t,e,n)=>t+e+n+(r/4294967296|0)|0,sf=(r,t,e,n)=>(r>>>0)+(t>>>0)+(e>>>0)+(n>>>0),af=(r,t,e,n,i)=>t+e+n+i+(r/4294967296|0)|0,cf=(r,t,e,n,i)=>(r>>>0)+(t>>>0)+(e>>>0)+(n>>>0)+(i>>>0),uf=(r,t,e,n,i,o)=>t+e+n+i+o+(r/4294967296|0)|0,lf={fromBig:la,split:Wd,toBig:Md,shrSH:jd,shrSL:Dd,rotrSH:Vd,rotrSL:Gd,rotrBH:Zd,rotrBL:Jd,rotr32H:Yd,rotr32L:Xd,rotlSH:Qd,rotlSL:tf,rotlBH:ef,rotlBL:rf,add:$d,add3L:nf,add3H:of,add4L:sf,add4H:af,add5H:uf,add5L:cf},et=lf,[hf,df]=et.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(r=>BigInt(r))),He=new Uint32Array(80),qe=new Uint32Array(80);class ff extends Hi{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:t,Al:e,Bh:n,Bl:i,Ch:o,Cl:s,Dh:a,Dl:c,Eh:u,El:l,Fh:h,Fl:y,Gh:f,Gl:p,Hh:d,Hl:g}=this;return[t,e,n,i,o,s,a,c,u,l,h,y,f,p,d,g]}set(t,e,n,i,o,s,a,c,u,l,h,y,f,p,d,g){this.Ah=t|0,this.Al=e|0,this.Bh=n|0,this.Bl=i|0,this.Ch=o|0,this.Cl=s|0,this.Dh=a|0,this.Dl=c|0,this.Eh=u|0,this.El=l|0,this.Fh=h|0,this.Fl=y|0,this.Gh=f|0,this.Gl=p|0,this.Hh=d|0,this.Hl=g|0}process(t,e){for(let x=0;x<16;x++,e+=4)He[x]=t.getUint32(e),qe[x]=t.getUint32(e+=4);for(let x=16;x<80;x++){const C=He[x-15]|0,E=qe[x-15]|0,I=et.rotrSH(C,E,1)^et.rotrSH(C,E,8)^et.shrSH(C,E,7),P=et.rotrSL(C,E,1)^et.rotrSL(C,E,8)^et.shrSL(C,E,7),N=He[x-2]|0,rt=qe[x-2]|0,X=et.rotrSH(N,rt,19)^et.rotrBH(N,rt,61)^et.shrSH(N,rt,6),Z=et.rotrSL(N,rt,19)^et.rotrBL(N,rt,61)^et.shrSL(N,rt,6),ht=et.add4L(P,Z,qe[x-7],qe[x-16]),ut=et.add4H(ht,I,X,He[x-7],He[x-16]);He[x]=ut|0,qe[x]=ht|0}let{Ah:n,Al:i,Bh:o,Bl:s,Ch:a,Cl:c,Dh:u,Dl:l,Eh:h,El:y,Fh:f,Fl:p,Gh:d,Gl:g,Hh:S,Hl:B}=this;for(let x=0;x<80;x++){const C=et.rotrSH(h,y,14)^et.rotrSH(h,y,18)^et.rotrBH(h,y,41),E=et.rotrSL(h,y,14)^et.rotrSL(h,y,18)^et.rotrBL(h,y,41),I=h&f^~h&d,P=y&p^~y&g,N=et.add5L(B,E,P,df[x],qe[x]),rt=et.add5H(N,S,C,I,hf[x],He[x]),X=N|0,Z=et.rotrSH(n,i,28)^et.rotrBH(n,i,34)^et.rotrBH(n,i,39),ht=et.rotrSL(n,i,28)^et.rotrBL(n,i,34)^et.rotrBL(n,i,39),ut=n&o^n&a^o&a,Nt=i&s^i&c^s&c;S=d|0,B=g|0,d=f|0,g=p|0,f=h|0,p=y|0,{h,l:y}=et.add(u|0,l|0,rt|0,X|0),u=a|0,l=c|0,a=o|0,c=s|0,o=n|0,s=i|0;const T=et.add3L(X,ht,Nt);n=et.add3H(T,rt,Z,ut),i=T|0}({h:n,l:i}=et.add(this.Ah|0,this.Al|0,n|0,i|0)),{h:o,l:s}=et.add(this.Bh|0,this.Bl|0,o|0,s|0),{h:a,l:c}=et.add(this.Ch|0,this.Cl|0,a|0,c|0),{h:u,l}=et.add(this.Dh|0,this.Dl|0,u|0,l|0),{h,l:y}=et.add(this.Eh|0,this.El|0,h|0,y|0),{h:f,l:p}=et.add(this.Fh|0,this.Fl|0,f|0,p|0),{h:d,l:g}=et.add(this.Gh|0,this.Gl|0,d|0,g|0),{h:S,l:B}=et.add(this.Hh|0,this.Hl|0,S|0,B|0),this.set(n,i,o,s,a,c,u,l,h,y,f,p,d,g,S,B)}roundClean(){He.fill(0),qe.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}var Fi=zi(()=>new ff);function Ki(r){return r instanceof Uint8Array||r!=null&&typeof r=="object"&&r.constructor.name==="Uint8Array"}function Wi(r){if(!Ki(r))throw new Error("Uint8Array expected")}function $i(r){Wi(r);let t="";for(let e=0;e<r.length;e++)t+=mf[r[e]];return t}function ha(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return BigInt(r===""?"0":`0x${r}`)}function da(r){if(r>=Be._0&&r<=Be._9)return r-Be._0;if(r>=Be._A&&r<=Be._F)return r-(Be._A-10);if(r>=Be._a&&r<=Be._f)return r-(Be._a-10)}function fa(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);const t=r.length,e=t/2;if(t%2)throw new Error("padded hex string expected, got unpadded hex of length "+t);const n=new Uint8Array(e);for(let i=0,o=0;i<e;i++,o+=2){const s=da(r.charCodeAt(o)),a=da(r.charCodeAt(o+1));if(s===void 0||a===void 0){const c=r[o]+r[o+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+o)}n[i]=s*16+a}return n}function pf(r){return ha($i(r))}function xn(r){return Wi(r),ha($i(Uint8Array.from(r).reverse()))}function pa(r,t){return fa(r.toString(16).padStart(t*2,"0"))}function Mi(r,t){return pa(r,t).reverse()}function Fe(r,t,e){let n;if(typeof t=="string")try{n=fa(t)}catch(o){throw new Error(`${r} must be valid hex string, got "${t}". Cause: ${o}`)}else if(Ki(t))n=Uint8Array.from(t);else throw new Error(`${r} must be hex string or Uint8Array`);const i=n.length;if(typeof e=="number"&&i!==e)throw new Error(`${r} expected ${e} bytes, got ${i}`);return n}function ga(...r){let t=0;for(let n=0;n<r.length;n++){const i=r[n];Wi(i),t+=i.length}const e=new Uint8Array(t);for(let n=0,i=0;n<r.length;n++){const o=r[n];e.set(o,i),i+=o.length}return e}function ji(r,t,e={}){const n=(i,o,s)=>{const a=wf[o];if(typeof a!="function")throw new Error(`Invalid validator "${o}", expected function`);const c=r[i];if(!(s&&c===void 0)&&!a(c,r))throw new Error(`Invalid param ${String(i)}=${c} (${typeof c}), expected ${o}`)};for(let[i,o]of Object.entries(t))n(i,o,!1);for(let[i,o]of Object.entries(e))n(i,o,!0);return r}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var gf=BigInt(1),yf=BigInt(2),mf=Array.from({length:256},(r,t)=>t.toString(16).padStart(2,"0")),Be={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102},bf=r=>(yf<<BigInt(r-1))-gf,wf={bigint:r=>typeof r=="bigint",function:r=>typeof r=="function",boolean:r=>typeof r=="boolean",string:r=>typeof r=="string",stringOrUint8Array:r=>typeof r=="string"||Ki(r),isSafeInteger:r=>Number.isSafeInteger(r),array:r=>Array.isArray(r),field:(r,t)=>t.Fp.isValid(r),hash:r=>typeof r=="function"&&Number.isSafeInteger(r.outputLen)};function At(r,t){const e=r%t;return e>=Lt?e:t+e}function vf(r,t,e){if(e<=Lt||t<Lt)throw new Error("Expected power/modulo > 0");if(e===Et)return Lt;let n=Et;for(;t>Lt;)t&Et&&(n=n*r%e),r=r*r%e,t>>=Et;return n}function be(r,t,e){let n=r;for(;t-- >Lt;)n*=n,n%=e;return n}function ya(r,t){if(r===Lt||t<=Lt)throw new Error(`invert: expected positive integers, got n=${r} mod=${t}`);let e=At(r,t),n=t,i=Lt,o=Et;for(;e!==Lt;){const s=n/e,a=n%e,c=i-o*s;n=e,e=a,i=o,o=c}if(n!==Et)throw new Error("invert: does not exist");return At(i,t)}function Sf(r){const t=(r-Et)/ir;let e,n,i;for(e=r-Et,n=0;e%ir===Lt;e/=ir,n++);for(i=ir;i<r&&vf(i,t,r)!==r-Et;i++);if(n===1){const s=(r+Et)/Di;return function(a,c){const u=a.pow(c,s);if(!a.eql(a.sqr(u),c))throw new Error("Cannot find square root");return u}}const o=(e+Et)/ir;return function(s,a){if(s.pow(a,t)===s.neg(s.ONE))throw new Error("Cannot find square root");let c=n,u=s.pow(s.mul(s.ONE,i),e),l=s.pow(a,o),h=s.pow(a,e);for(;!s.eql(h,s.ONE);){if(s.eql(h,s.ZERO))return s.ZERO;let y=1;for(let p=s.sqr(h);y<c&&!s.eql(p,s.ONE);y++)p=s.sqr(p);const f=s.pow(u,Et<<BigInt(c-y-1));u=s.sqr(f),l=s.mul(l,f),h=s.mul(h,u),c=y}return l}}function xf(r){if(r%Di===If){const t=(r+Et)/Di;return function(e,n){const i=e.pow(n,t);if(!e.eql(e.sqr(i),n))throw new Error("Cannot find square root");return i}}if(r%wa===ba){const t=(r-ba)/wa;return function(e,n){const i=e.mul(n,ir),o=e.pow(i,t),s=e.mul(n,o),a=e.mul(e.mul(s,ir),o),c=e.mul(s,e.sub(a,e.ONE));if(!e.eql(e.sqr(c),n))throw new Error("Cannot find square root");return c}}return Sf(r)}function Ef(r){const t={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=Lf.reduce((n,i)=>(n[i]="function",n),t);return ji(r,e)}function kf(r,t,e){if(e<Lt)throw new Error("Expected power > 0");if(e===Lt)return r.ONE;if(e===Et)return t;let n=r.ONE,i=t;for(;e>Lt;)e&Et&&(n=r.mul(n,i)),i=r.sqr(i),e>>=Et;return n}function Bf(r,t){const e=new Array(t.length),n=t.reduce((o,s,a)=>r.is0(s)?o:(e[a]=o,r.mul(o,s)),r.ONE),i=r.inv(n);return t.reduceRight((o,s,a)=>r.is0(s)?o:(e[a]=r.mul(o,e[a]),r.mul(o,s)),i),e}function ma(r,t){const e=t!==void 0?t:r.toString(2).length,n=Math.ceil(e/8);return{nBitLength:e,nByteLength:n}}function Af(r,t,e=!1,n={}){if(r<=Lt)throw new Error(`Expected Field ORDER > 0, got ${r}`);const{nBitLength:i,nByteLength:o}=ma(r,t);if(o>2048)throw new Error("Field lengths over 2048 bytes are not supported");const s=xf(r),a=Object.freeze({ORDER:r,BITS:i,BYTES:o,MASK:bf(i),ZERO:Lt,ONE:Et,create:c=>At(c,r),isValid:c=>{if(typeof c!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);return Lt<=c&&c<r},is0:c=>c===Lt,isOdd:c=>(c&Et)===Et,neg:c=>At(-c,r),eql:(c,u)=>c===u,sqr:c=>At(c*c,r),add:(c,u)=>At(c+u,r),sub:(c,u)=>At(c-u,r),mul:(c,u)=>At(c*u,r),pow:(c,u)=>kf(a,c,u),div:(c,u)=>At(c*ya(u,r),r),sqrN:c=>c*c,addN:(c,u)=>c+u,subN:(c,u)=>c-u,mulN:(c,u)=>c*u,inv:c=>ya(c,r),sqrt:n.sqrt||(c=>s(a,c)),invertBatch:c=>Bf(a,c),cmov:(c,u,l)=>l?u:c,toBytes:c=>e?Mi(c,o):pa(c,o),fromBytes:c=>{if(c.length!==o)throw new Error(`Fp.fromBytes: expected ${o}, got ${c.length}`);return e?xn(c):pf(c)}});return Object.freeze(a)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var Lt=BigInt(0),Et=BigInt(1),ir=BigInt(2),If=BigInt(3),Di=BigInt(4),ba=BigInt(5),wa=BigInt(8);BigInt(9),BigInt(16);var _f=(r,t)=>(At(r,t)&Et)===Et,Lf=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Cf(r,t){const e=(i,o)=>{const s=o.negate();return i?s:o},n=i=>{const o=Math.ceil(t/i)+1,s=2**(i-1);return{windows:o,windowSize:s}};return{constTimeNegate:e,unsafeLadder(i,o){let s=r.ZERO,a=i;for(;o>Of;)o&Vi&&(s=s.add(a)),a=a.double(),o>>=Vi;return s},precomputeWindow(i,o){const{windows:s,windowSize:a}=n(o),c=[];let u=i,l=u;for(let h=0;h<s;h++){l=u,c.push(l);for(let y=1;y<a;y++)l=l.add(u),c.push(l);u=l.double()}return c},wNAF(i,o,s){const{windows:a,windowSize:c}=n(i);let{ZERO:u,BASE:l}=r;const h=BigInt(2**i-1),y=2**i,f=BigInt(i);for(let p=0;p<a;p++){const d=p*c;let g=Number(s&h);s>>=f,g>c&&(g-=y,s+=Vi);const S=d,B=d+Math.abs(g)-1,x=p%2!==0,C=g<0;g===0?l=l.add(e(x,o[S])):u=u.add(e(C,o[B]))}return{p:u,f:l}},wNAFCached(i,o,s,a){const c=i._WINDOW_SIZE||1;let u=o.get(i);return u||(u=this.precomputeWindow(i,c),c!==1&&o.set(i,a(u))),this.wNAF(c,u,s)}}}function Tf(r){return Ef(r.Fp),ji(r,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...ma(r.n,r.nBitLength),...r,p:r.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var Of=BigInt(0),Vi=BigInt(1);function Pf(r){const t=Tf(r);return ji(r,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...t})}function Rf(r){const t=Pf(r),{Fp:e,n,prehash:i,hash:o,randomBytes:s,nByteLength:a,h:c}=t,u=En<<BigInt(a*8)-Yt,l=e.create,h=t.uvRatio||((v,m)=>{try{return{isValid:!0,value:e.sqrt(v*e.inv(m))}}catch{return{isValid:!1,value:ue}}}),y=t.adjustScalarBytes||(v=>v),f=t.domain||((v,m,k)=>{if(m.length||k)throw new Error("Contexts/pre-hash are not supported");return v}),p=v=>typeof v=="bigint"&&ue<v,d=(v,m)=>p(v)&&p(m)&&v<m,g=v=>v===ue||d(v,u);function S(v,m){if(d(v,m))return v;throw new Error(`Expected valid scalar < ${m}, got ${typeof v} ${v}`)}function B(v){return v===ue?v:S(v,n)}const x=new Map;function C(v){if(!(v instanceof E))throw new Error("ExtendedPoint expected")}class E{constructor(m,k,_,R){if(this.ex=m,this.ey=k,this.ez=_,this.et=R,!g(m))throw new Error("x required");if(!g(k))throw new Error("y required");if(!g(_))throw new Error("z required");if(!g(R))throw new Error("t required")}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(m){if(m instanceof E)throw new Error("extended point not allowed");const{x:k,y:_}=m||{};if(!g(k)||!g(_))throw new Error("invalid affine point");return new E(k,_,Yt,l(k*_))}static normalizeZ(m){const k=e.invertBatch(m.map(_=>_.ez));return m.map((_,R)=>_.toAffine(k[R])).map(E.fromAffine)}_setWindowSize(m){this._WINDOW_SIZE=m,x.delete(this)}assertValidity(){const{a:m,d:k}=t;if(this.is0())throw new Error("bad point: ZERO");const{ex:_,ey:R,ez:z,et:F}=this,D=l(_*_),K=l(R*R),V=l(z*z),J=l(V*V),st=l(D*m),dt=l(V*l(st+K)),ot=l(J+l(k*l(D*K)));if(dt!==ot)throw new Error("bad point: equation left != right (1)");const vt=l(_*R),ct=l(z*F);if(vt!==ct)throw new Error("bad point: equation left != right (2)")}equals(m){C(m);const{ex:k,ey:_,ez:R}=this,{ex:z,ey:F,ez:D}=m,K=l(k*D),V=l(z*R),J=l(_*D),st=l(F*R);return K===V&&J===st}is0(){return this.equals(E.ZERO)}negate(){return new E(l(-this.ex),this.ey,this.ez,l(-this.et))}double(){const{a:m}=t,{ex:k,ey:_,ez:R}=this,z=l(k*k),F=l(_*_),D=l(En*l(R*R)),K=l(m*z),V=k+_,J=l(l(V*V)-z-F),st=K+F,dt=st-D,ot=K-F,vt=l(J*dt),ct=l(st*ot),zt=l(J*ot),jt=l(dt*st);return new E(vt,ct,jt,zt)}add(m){C(m);const{a:k,d:_}=t,{ex:R,ey:z,ez:F,et:D}=this,{ex:K,ey:V,ez:J,et:st}=m;if(k===BigInt(-1)){const Sr=l((z-R)*(V+K)),xr=l((z+R)*(V-K)),Me=l(xr-Sr);if(Me===ue)return this.double();const Er=l(F*En*st),kr=l(D*En*J),Br=kr+Er,Ar=xr+Sr,Ir=kr-Er,On=l(Br*Me),Pn=l(Ar*Ir),Rn=l(Br*Ir),Un=l(Me*Ar);return new E(On,Pn,Un,Rn)}const dt=l(R*K),ot=l(z*V),vt=l(D*_*st),ct=l(F*J),zt=l((R+z)*(K+V)-dt-ot),jt=ct-vt,Ae=ct+vt,Ie=l(ot-k*dt),_n=l(zt*jt),Ln=l(Ae*Ie),Cn=l(zt*Ie),Tn=l(jt*Ae);return new E(_n,Ln,Tn,Cn)}subtract(m){return this.add(m.negate())}wNAF(m){return N.wNAFCached(this,x,m,E.normalizeZ)}multiply(m){const{p:k,f:_}=this.wNAF(S(m,n));return E.normalizeZ([k,_])[0]}multiplyUnsafe(m){let k=B(m);return k===ue?P:this.equals(P)||k===Yt?this:this.equals(I)?this.wNAF(k).p:N.unsafeLadder(this,k)}isSmallOrder(){return this.multiplyUnsafe(c).is0()}isTorsionFree(){return N.unsafeLadder(this,n).is0()}toAffine(m){const{ex:k,ey:_,ez:R}=this,z=this.is0();m==null&&(m=z?Uf:e.inv(R));const F=l(k*m),D=l(_*m),K=l(R*m);if(z)return{x:ue,y:Yt};if(K!==Yt)throw new Error("invZ was invalid");return{x:F,y:D}}clearCofactor(){const{h:m}=t;return m===Yt?this:this.multiplyUnsafe(m)}static fromHex(m,k=!1){const{d:_,a:R}=t,z=e.BYTES;m=Fe("pointHex",m,z);const F=m.slice(),D=m[z-1];F[z-1]=D&-129;const K=xn(F);K===ue||(k?S(K,u):S(K,e.ORDER));const V=l(K*K),J=l(V-Yt),st=l(_*V-R);let{isValid:dt,value:ot}=h(J,st);if(!dt)throw new Error("Point.fromHex: invalid y coordinate");const vt=(ot&Yt)===Yt,ct=(D&128)!==0;if(!k&&ot===ue&&ct)throw new Error("Point.fromHex: x=0 and x_0=1");return ct!==vt&&(ot=l(-ot)),E.fromAffine({x:ot,y:K})}static fromPrivateKey(m){return Z(m).point}toRawBytes(){const{x:m,y:k}=this.toAffine(),_=Mi(k,e.BYTES);return _[_.length-1]|=m&Yt?128:0,_}toHex(){return $i(this.toRawBytes())}}E.BASE=new E(t.Gx,t.Gy,Yt,l(t.Gx*t.Gy)),E.ZERO=new E(ue,Yt,Yt,ue);const{BASE:I,ZERO:P}=E,N=Cf(E,a*8);function rt(v){return At(v,n)}function X(v){return rt(xn(v))}function Z(v){const m=a;v=Fe("private key",v,m);const k=Fe("hashed private key",o(v),2*m),_=y(k.slice(0,m)),R=k.slice(m,2*m),z=X(_),F=I.multiply(z),D=F.toRawBytes();return{head:_,prefix:R,scalar:z,point:F,pointBytes:D}}function ht(v){return Z(v).pointBytes}function ut(v=new Uint8Array,...m){const k=ga(...m);return X(o(f(k,Fe("context",v),!!i)))}function Nt(v,m,k={}){v=Fe("message",v),i&&(v=i(v));const{prefix:_,scalar:R,pointBytes:z}=Z(m),F=ut(k.context,_,v),D=I.multiply(F).toRawBytes(),K=ut(k.context,D,z,v),V=rt(F+K*R);B(V);const J=ga(D,Mi(V,e.BYTES));return Fe("result",J,a*2)}const T=Nf;function $(v,m,k,_=T){const{context:R,zip215:z}=_,F=e.BYTES;v=Fe("signature",v,2*F),m=Fe("message",m),i&&(m=i(m));const D=xn(v.slice(F,2*F));let K,V,J;try{K=E.fromHex(k,z),V=E.fromHex(v.slice(0,F),z),J=I.multiplyUnsafe(D)}catch{return!1}if(!z&&K.isSmallOrder())return!1;const st=ut(R,V.toRawBytes(),K.toRawBytes(),m);return V.add(K.multiplyUnsafe(st)).subtract(J).clearCofactor().equals(E.ZERO)}return I._setWindowSize(8),{CURVE:t,getPublicKey:ht,sign:Nt,verify:$,ExtendedPoint:E,utils:{getExtendedPublicKey:Z,randomPrivateKey:()=>s(e.BYTES),precompute(v=8,m=E.BASE){return m._setWindowSize(v),m.multiply(BigInt(3)),m}}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var ue=BigInt(0),Yt=BigInt(1),En=BigInt(2),Uf=BigInt(8),Nf={zip215:!0};function zf(r){const t=BigInt(10),e=BigInt(20),n=BigInt(40),i=BigInt(80),o=Gi,s=r*r%o*r%o,a=be(s,Sa,o)*s%o,c=be(a,Ff,o)*r%o,u=be(c,Kf,o)*c%o,l=be(u,t,o)*u%o,h=be(l,e,o)*l%o,y=be(h,n,o)*h%o,f=be(y,i,o)*y%o,p=be(f,i,o)*y%o,d=be(p,t,o)*u%o;return{pow_p_5_8:be(d,Sa,o)*r%o,b2:s}}function Hf(r){return r[0]&=248,r[31]&=127,r[31]|=64,r}function qf(r,t){const e=Gi,n=At(t*t*t,e),i=At(n*n*t,e),o=zf(r*i).pow_p_5_8;let s=At(r*n*o,e);const a=At(t*s*s,e),c=s,u=At(s*va,e),l=a===r,h=a===At(-r,e),y=a===At(-r*va,e);return l&&(s=c),(h||y)&&(s=u),_f(s,e)&&(s=At(-s,e)),{isValid:l||h,value:s}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var Gi=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),va=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");BigInt(0);var Ff=BigInt(1),Sa=BigInt(2);BigInt(3);var Kf=BigInt(5),Wf=BigInt(8),$f=Af(Gi,void 0,!0),Mf={a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:$f,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:Wf,Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:Fi,randomBytes:zd,adjustScalarBytes:Hf,uvRatio:qf},Zi=Rf(Mf);class xa extends ua{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,Rd(t);const n=Ni(e);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const i=this.blockLen,o=new Uint8Array(i);o.set(n.length>i?t.create().update(n).digest():n);for(let s=0;s<o.length;s++)o[s]^=54;this.iHash.update(o),this.oHash=t.create();for(let s=0;s<o.length;s++)o[s]^=106;this.oHash.update(o),o.fill(0)}update(t){return wn(this),this.iHash.update(t),this}digestInto(t){wn(this),ze(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:n,finished:i,destroyed:o,blockLen:s,outputLen:a}=this;return t=t,t.finished=i,t.destroyed=o,t.blockLen=s,t.outputLen=a,t.oHash=e._cloneInto(t.oHash),t.iHash=n._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}var Ji=(r,t,e)=>new xa(r,t).update(e).digest();Ji.create=(r,t)=>new xa(r,t);function Ea(r,t,e,n){return r===0?t^e^n:r===1?t&e|~t&n:r===2?(t|~e)^n:r===3?t&n|e&~n:t^(e|~n)}var jf=new Uint8Array([7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8]),ka=new Uint8Array(new Array(16).fill(0).map((r,t)=>t)),Df=ka.map(r=>(9*r+5)%16),Yi=[ka],Xi=[Df];for(let r=0;r<4;r++)for(let t of[Yi,Xi])t.push(t[r].map(e=>jf[e]));var Ba=[[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8],[12,13,11,15,6,9,9,7,12,15,11,13,7,8,7,7],[13,15,14,11,7,7,6,8,13,14,13,12,5,5,6,9],[14,11,12,14,8,6,5,5,15,12,15,14,9,9,8,6],[15,12,13,13,9,5,8,6,14,11,12,11,8,6,5,5]].map(r=>new Uint8Array(r)),Vf=Yi.map((r,t)=>r.map(e=>Ba[t][e])),Gf=Xi.map((r,t)=>r.map(e=>Ba[t][e])),Zf=new Uint32Array([0,1518500249,1859775393,2400959708,2840853838]),Jf=new Uint32Array([1352829926,1548603684,1836072691,2053994217,0]),kn=new Uint32Array(16);class Yf extends Hi{constructor(){super(64,20,8,!0),this.h0=1732584193,this.h1=-271733879,this.h2=-1732584194,this.h3=271733878,this.h4=-1009589776}get(){const{h0:t,h1:e,h2:n,h3:i,h4:o}=this;return[t,e,n,i,o]}set(t,e,n,i,o){this.h0=t|0,this.h1=e|0,this.h2=n|0,this.h3=i|0,this.h4=o|0}process(t,e){for(let f=0;f<16;f++,e+=4)kn[f]=t.getUint32(e,!0);let n=this.h0|0,i=n,o=this.h1|0,s=o,a=this.h2|0,c=a,u=this.h3|0,l=u,h=this.h4|0,y=h;for(let f=0;f<5;f++){const p=4-f,d=Zf[f],g=Jf[f],S=Yi[f],B=Xi[f],x=Vf[f],C=Gf[f];for(let E=0;E<16;E++){const I=vn(n+Ea(f,o,a,u)+kn[S[E]]+d,x[E])+h|0;n=h,h=u,u=vn(a,10)|0,a=o,o=I}for(let E=0;E<16;E++){const I=vn(i+Ea(p,s,c,l)+kn[B[E]]+g,C[E])+y|0;i=y,y=l,l=vn(c,10)|0,c=s,s=I}}this.set(this.h1+a+l|0,this.h2+u+y|0,this.h3+h+i|0,this.h4+n+s|0,this.h0+o+c|0)}roundClean(){kn.fill(0)}destroy(){this.destroyed=!0,this.buffer.fill(0),this.set(0,0,0,0,0)}}var Xf=zi(()=>new Yf),Qf=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Ke=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),We=new Uint32Array(64);class tp extends Hi{constructor(){super(64,32,8,!1),this.A=Ke[0]|0,this.B=Ke[1]|0,this.C=Ke[2]|0,this.D=Ke[3]|0,this.E=Ke[4]|0,this.F=Ke[5]|0,this.G=Ke[6]|0,this.H=Ke[7]|0}get(){const{A:t,B:e,C:n,D:i,E:o,F:s,G:a,H:c}=this;return[t,e,n,i,o,s,a,c]}set(t,e,n,i,o,s,a,c){this.A=t|0,this.B=e|0,this.C=n|0,this.D=i|0,this.E=o|0,this.F=s|0,this.G=a|0,this.H=c|0}process(t,e){for(let h=0;h<16;h++,e+=4)We[h]=t.getUint32(e,!1);for(let h=16;h<64;h++){const y=We[h-15],f=We[h-2],p=me(y,7)^me(y,18)^y>>>3,d=me(f,17)^me(f,19)^f>>>10;We[h]=d+We[h-7]+p+We[h-16]|0}let{A:n,B:i,C:o,D:s,E:a,F:c,G:u,H:l}=this;for(let h=0;h<64;h++){const y=me(a,6)^me(a,11)^me(a,25),f=l+y+Fd(a,c,u)+Qf[h]+We[h]|0,p=(me(n,2)^me(n,13)^me(n,22))+Kd(n,i,o)|0;l=u,u=c,c=a,a=s+f|0,s=o,o=i,i=n,n=f+p|0}n=n+this.A|0,i=i+this.B|0,o=o+this.C|0,s=s+this.D|0,a=a+this.E|0,c=c+this.F|0,u=u+this.G|0,l=l+this.H|0,this.set(n,i,o,s,a,c,u,l)}roundClean(){We.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}var ep=zi(()=>new tp);function Aa(r,...t){return typeof r=="string"&&(r=Nd(r)),ze(r,...t),r}/*! micro-key-producer - MIT License (c) 2024 Paul Miller (paulmillr.com) */var rp=aa("ed25519 seed"),Qi=2147483648,Ia=new Uint8Array([0]),np=r=>Xf(ep(r)),ip=r=>Wr(r).getUint32(0,!1),to=r=>{if(!Number.isSafeInteger(r)||r<0||r>4294967295)throw new Error(`Invalid number=${r}. Should be from 0 to 2 ** 32 - 1`);const t=new Uint8Array(4);return Wr(t).setUint32(0,r,!1),t};class In{get publicKeyRaw(){return Zi.getPublicKey(this.privateKey)}get publicKey(){return ca(Ia,this.publicKeyRaw)}get pubHash(){return np(this.publicKey)}get fingerprint(){return ip(this.pubHash)}get fingerprintHex(){return oa(to(this.fingerprint))}get parentFingerprintHex(){return oa(to(this.parentFingerprint))}static fromMasterSeed(t){if(t=Aa(t),8*t.length<128||8*t.length>512)throw new Error(`HDKey: wrong seed length=${t.length}. Should be between 128 and 512 bits; 256 bits is advised)`);const e=Ji(Fi,rp,t);return new In({privateKey:e.slice(0,32),chainCode:e.slice(32)})}constructor(t){if(this.depth=0,this.index=0,this.parentFingerprint=0,!t||typeof t!="object")throw new Error("HDKey.constructor must not be called directly");if(ze(t.privateKey,32),ze(t.chainCode,32),this.depth=t.depth||0,this.index=t.index||0,this.parentFingerprint=t.parentFingerprint||0,!this.depth&&(this.parentFingerprint||this.index))throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");this.chainCode=t.chainCode,this.privateKey=t.privateKey}derive(t,e=!1){if(!/^[mM]'?/.test(t))throw new Error('Path must start with "m" or "M"');if(/^[mM]'?$/.test(t))return this;const n=t.replace(/^[mM]'?\//,"").split("/");let i=this;for(let o of n){const s=/^(\d+)('?)$/.exec(o);if(!s||s.length!==3)throw new Error(`Invalid child index: ${o}`);let a=+s[1];if(!Number.isSafeInteger(a)||a>=Qi)throw new Error("Invalid index");(e||s[2]==="'")&&(a+=Qi),i=i.deriveChild(a)}return i}deriveChild(t){if(t<Qi)throw new Error(`Non-hardened child derivation not possible for Ed25519 (index=${t})`);const e=ca(Ia,this.privateKey,to(t)),n=Ji(Fi,this.chainCode,e);return new In({chainCode:n.slice(32),depth:this.depth+1,parentFingerprint:this.fingerprint,index:t,privateKey:n.slice(0,32)})}sign(t){return Zi.sign(t,this.privateKey)}verify(t,e){return e=Aa(e,64),Zi.verify(e,t,this.publicKeyRaw)}}function _a(r){try{const t=new q(r);return q.isOnCurve(t.toBuffer())}catch{return!1}}function op({phrase:r,derivationPath:t=Ua.SOL}){const e=Ra(r),n=In.fromMasterSeed(e);return $r.fromSeed(n.derive(t,!0).privateKey)}function sp(r){return r.publicKey.toString()}async function ap({connection:r,address:t}){const e=await r.getTokenAccountsByOwner(new q(t),{programId:Ee}),n=[];for await(let i of e.value){const o=Pi.decode(i.account.data),{decimals:s,address:a}=await _d(r,o.mint);o.amount>BigInt(0)&&n.push(new ao({value:Na.fromBigInt(o.amount,s),decimal:s,identifier:`${co.Solana}.TOKEN-${a.toString()}`}))}return n}function cp(r){return async t=>{const e=await r.getBalance(new q(t)),n=await ap({connection:r,address:t});return[ao.from({chain:co.Solana,value:BigInt(e)}),...n]}}async function up({tokenAddress:r,recipient:t,from:e,connection:n,amount:i,decimals:o}){const s=new le,a=new q(r),c=await ra(a,e),u=new q(t),l=await ra(a,u);try{return await Ad(n,l),s.add(Cd(c,a,l,e,i,o))}catch{return s.add(Td(e,l,u,a))}}function lp(r){return async({recipient:t,assetValue:e,fromKeypair:n})=>{if(!_a(t))throw new uo("core_transaction_invalid_sender_address");const i=e.isGasAsset?new le().add(vr.transfer({fromPubkey:n.publicKey,lamports:e.getValue("number"),toPubkey:new q(t)})):e.address?await up({amount:e.getValue("number"),connection:r,decimals:e.decimal,from:n.publicKey,recipient:t,tokenAddress:e.address}):void 0;if(!i)throw new uo("core_transaction_invalid_sender_address");const o=await r.getLatestBlockhash();return i.recentBlockhash=o.blockhash,i.feePayer=n.publicKey,ql(r,i,[n])}}var hp=({rpcUrl:r=Pa.Solana}={})=>{const t=new wd(r,"confirmed");return{createKeysForPath:op,getAddressFromKeys:sp,getBalance:cp(t),transfer:lp(t),validateAddress:_a}};export{hp as SOLToolbox};
